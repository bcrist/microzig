// this file was generated by regz: https://github.com/ZigEmbeddedGroup/regz
// commit: 62e33d0e2175e4c1621e1dbf9f6ac3ec18f6ba38
//
// device: STM32G030
// cpu: CM0

pub const VectorTable = extern struct {
    initial_stack_pointer: u32,
    Reset: InterruptVector = unhandled,
    NMI: InterruptVector = unhandled,
    HardFault: InterruptVector = unhandled,
    reserved0: [7]u32 = undefined,
    SVCall: InterruptVector = unhandled,
    reserved1: [2]u32 = undefined,
    PendSV: InterruptVector = unhandled,
    SysTick: InterruptVector = unhandled,
    /// Window watchdog interrupt
    WWDG: InterruptVector = unhandled,
    /// Power voltage detector interrupt
    PVD: InterruptVector = unhandled,
    /// RTC and TAMP interrupts
    RTC_TAMP: InterruptVector = unhandled,
    /// Flash global interrupt
    FLASH: InterruptVector = unhandled,
    /// RCC global interrupt
    RCC: InterruptVector = unhandled,
    /// EXTI line 0 & 1 interrupt
    EXTI0_1: InterruptVector = unhandled,
    /// EXTI line 2 & 3 interrupt
    EXTI2_3: InterruptVector = unhandled,
    /// EXTI line 4 to 15 interrupt
    EXTI4_15: InterruptVector = unhandled,
    reserved2: u32 = undefined,
    /// DMA channel 1 interrupt
    DMA_Channel1: InterruptVector = unhandled,
    /// DMA channel 2 & 3 interrupts
    DMA_Channel2_3: InterruptVector = unhandled,
    /// DMA channel 4, 5, 6 & 7 and
    /// DMAMUX
    DMA_Channel4_5_6_7: InterruptVector = unhandled,
    /// ADC and COMP interrupts
    ADC_COMP: InterruptVector = unhandled,
    /// TIM1 break, update, trigger
    TIM1_BRK_UP_TRG_COM: InterruptVector = unhandled,
    /// TIM1 Capture Compare interrupt
    TIM1_CC: InterruptVector = unhandled,
    /// TIM2 global interrupt
    TIM2: InterruptVector = unhandled,
    /// TIM3 global interrupt
    TIM3: InterruptVector = unhandled,
    reserved3: u32 = undefined,
    reserved4: u32 = undefined,
    /// TIM14 global interrupt
    TIM14: InterruptVector = unhandled,
    reserved5: u32 = undefined,
    /// TIM16 global interrupt
    TIM16: InterruptVector = unhandled,
    /// TIM17 global interrupt
    TIM17: InterruptVector = unhandled,
    /// I2C1 global interrupt
    I2C1: InterruptVector = unhandled,
    /// I2C2 global interrupt
    I2C2: InterruptVector = unhandled,
    /// SPI1 global interrupt
    SPI1: InterruptVector = unhandled,
    /// SPI2 global interrupt
    SPI2: InterruptVector = unhandled,
    /// USART1 global interrupt
    USART1: InterruptVector = unhandled,
    /// USART2 global interrupt
    USART2: InterruptVector = unhandled,
    reserved6: u32 = undefined,
    /// CEC global interrupt
    CEC: InterruptVector = unhandled,
};

pub const registers = struct {
    /// System Control Space
    pub const SCS = struct {
        pub const base_address = 0xe000e000;

        /// System Tick Timer
        pub const SysTick = struct {
            /// address: 0xe000e010
            /// SysTick Control and Status Register
            pub const CTRL = @intToPtr(*volatile Mmio(32, packed struct {
                ENABLE: u1,
                TICKINT: u1,
                CLKSOURCE: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                COUNTFLAG: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
            }), base_address + 0x10);

            /// address: 0xe000e014
            /// SysTick Reload Value Register
            pub const LOAD = @intToPtr(*volatile Mmio(32, packed struct {
                RELOAD: u24,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
            }), base_address + 0x14);

            /// address: 0xe000e018
            /// SysTick Current Value Register
            pub const VAL = @intToPtr(*volatile Mmio(32, packed struct {
                CURRENT: u24,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
            }), base_address + 0x18);

            /// address: 0xe000e01c
            /// SysTick Calibration Register
            pub const CALIB = @intToPtr(*volatile Mmio(32, packed struct {
                TENMS: u24,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                SKEW: u1,
                NOREF: u1,
            }), base_address + 0x1c);
        };

        /// Nested Vectored Interrupt Controller
        pub const NVIC = struct {
            /// address: 0xe000e100
            /// Interrupt Set Enable Register
            pub const ISER = @intToPtr(*volatile Mmio(32, packed struct {
                WWDG: u1,
                PVD: u1,
                RTC_TAMP: u1,
                FLASH: u1,
                RCC: u1,
                EXTI0_1: u1,
                EXTI2_3: u1,
                EXTI4_15: u1,
                reserved0: u1,
                DMA_Channel1: u1,
                DMA_Channel2_3: u1,
                DMA_Channel4_5_6_7: u1,
                ADC_COMP: u1,
                TIM1_BRK_UP_TRG_COM: u1,
                TIM1_CC: u1,
                TIM2: u1,
                TIM3: u1,
                reserved1: u1,
                reserved2: u1,
                TIM14: u1,
                reserved3: u1,
                TIM16: u1,
                TIM17: u1,
                I2C1: u1,
                I2C2: u1,
                SPI1: u1,
                SPI2: u1,
                USART1: u1,
                USART2: u1,
                reserved4: u1,
                CEC: u1,
                padding0: u1,
            }), base_address + 0x100);

            /// address: 0xe000e180
            /// Interrupt Clear Enable Register
            pub const ICER = @intToPtr(*volatile Mmio(32, packed struct {
                WWDG: u1,
                PVD: u1,
                RTC_TAMP: u1,
                FLASH: u1,
                RCC: u1,
                EXTI0_1: u1,
                EXTI2_3: u1,
                EXTI4_15: u1,
                reserved0: u1,
                DMA_Channel1: u1,
                DMA_Channel2_3: u1,
                DMA_Channel4_5_6_7: u1,
                ADC_COMP: u1,
                TIM1_BRK_UP_TRG_COM: u1,
                TIM1_CC: u1,
                TIM2: u1,
                TIM3: u1,
                reserved1: u1,
                reserved2: u1,
                TIM14: u1,
                reserved3: u1,
                TIM16: u1,
                TIM17: u1,
                I2C1: u1,
                I2C2: u1,
                SPI1: u1,
                SPI2: u1,
                USART1: u1,
                USART2: u1,
                reserved4: u1,
                CEC: u1,
                padding0: u1,
            }), base_address + 0x180);

            /// address: 0xe000e200
            /// Interrupt Set Pending Register
            pub const ISPR = @intToPtr(*volatile Mmio(32, packed struct {
                WWDG: u1,
                PVD: u1,
                RTC_TAMP: u1,
                FLASH: u1,
                RCC: u1,
                EXTI0_1: u1,
                EXTI2_3: u1,
                EXTI4_15: u1,
                reserved0: u1,
                DMA_Channel1: u1,
                DMA_Channel2_3: u1,
                DMA_Channel4_5_6_7: u1,
                ADC_COMP: u1,
                TIM1_BRK_UP_TRG_COM: u1,
                TIM1_CC: u1,
                TIM2: u1,
                TIM3: u1,
                reserved1: u1,
                reserved2: u1,
                TIM14: u1,
                reserved3: u1,
                TIM16: u1,
                TIM17: u1,
                I2C1: u1,
                I2C2: u1,
                SPI1: u1,
                SPI2: u1,
                USART1: u1,
                USART2: u1,
                reserved4: u1,
                CEC: u1,
                padding0: u1,
            }), base_address + 0x200);

            /// address: 0xe000e280
            /// Interrupt Clear Pending Register
            pub const ICPR = @intToPtr(*volatile Mmio(32, packed struct {
                WWDG: u1,
                PVD: u1,
                RTC_TAMP: u1,
                FLASH: u1,
                RCC: u1,
                EXTI0_1: u1,
                EXTI2_3: u1,
                EXTI4_15: u1,
                reserved0: u1,
                DMA_Channel1: u1,
                DMA_Channel2_3: u1,
                DMA_Channel4_5_6_7: u1,
                ADC_COMP: u1,
                TIM1_BRK_UP_TRG_COM: u1,
                TIM1_CC: u1,
                TIM2: u1,
                TIM3: u1,
                reserved1: u1,
                reserved2: u1,
                TIM14: u1,
                reserved3: u1,
                TIM16: u1,
                TIM17: u1,
                I2C1: u1,
                I2C2: u1,
                SPI1: u1,
                SPI2: u1,
                USART1: u1,
                USART2: u1,
                reserved4: u1,
                CEC: u1,
                padding0: u1,
            }), base_address + 0x280);

            /// address: 0xe000e400
            /// Interrupt Priority Register
            pub const IP0 = @intToPtr(*volatile Mmio(32, packed struct {
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                WWDG: u4,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                PVD: u4,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                RTC_TAMP: u4,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                FLASH: u4,
            }), base_address + 0x400);

            /// address: 0xe000e404
            /// Interrupt Priority Register
            pub const IP1 = @intToPtr(*volatile Mmio(32, packed struct {
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                RCC: u4,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                EXTI0_1: u4,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                EXTI2_3: u4,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                EXTI4_15: u4,
            }), base_address + 0x404);

            /// address: 0xe000e408
            /// Interrupt Priority Register
            pub const IP2 = @intToPtr(*volatile Mmio(32, packed struct {
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                DMA_Channel1: u4,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                DMA_Channel2_3: u4,
                reserved16: u1,
                reserved17: u1,
                reserved18: u1,
                reserved19: u1,
                DMA_Channel4_5_6_7: u4,
            }), base_address + 0x408);

            /// address: 0xe000e40c
            /// Interrupt Priority Register
            pub const IP3 = @intToPtr(*volatile Mmio(32, packed struct {
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                ADC_COMP: u4,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                TIM1_BRK_UP_TRG_COM: u4,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                TIM1_CC: u4,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                TIM2: u4,
            }), base_address + 0x40c);

            /// address: 0xe000e410
            /// Interrupt Priority Register
            pub const IP4 = @intToPtr(*volatile Mmio(32, packed struct {
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                TIM3: u4,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                reserved16: u1,
                reserved17: u1,
                reserved18: u1,
                reserved19: u1,
                reserved20: u1,
                reserved21: u1,
                reserved22: u1,
                reserved23: u1,
                TIM14: u4,
            }), base_address + 0x410);

            /// address: 0xe000e414
            /// Interrupt Priority Register
            pub const IP5 = @intToPtr(*volatile Mmio(32, packed struct {
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                TIM16: u4,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                TIM17: u4,
                reserved16: u1,
                reserved17: u1,
                reserved18: u1,
                reserved19: u1,
                I2C1: u4,
            }), base_address + 0x414);

            /// address: 0xe000e418
            /// Interrupt Priority Register
            pub const IP6 = @intToPtr(*volatile Mmio(32, packed struct {
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                I2C2: u4,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                SPI1: u4,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                SPI2: u4,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                USART1: u4,
            }), base_address + 0x418);

            /// address: 0xe000e41c
            /// Interrupt Priority Register
            pub const IP7 = @intToPtr(*volatile Mmio(32, packed struct {
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                USART2: u4,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                reserved15: u1,
                CEC: u4,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
            }), base_address + 0x41c);
        };

        /// System Control Block
        pub const SCB = struct {
            /// address: 0xe000ed00
            pub const CPUID = @intToPtr(*volatile Mmio(32, packed struct {
                REVISION: u4,
                PARTNO: u12,
                ARCHITECTURE: u4,
                VARIANT: u4,
                IMPLEMENTER: u8,
            }), base_address + 0xd00);

            /// address: 0xe000ed04
            /// Interrupt Control and State Register
            pub const ICSR = @intToPtr(*volatile Mmio(32, packed struct {
                VECTACTIVE: u9,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                VECTPENDING: u9,
                reserved3: u1,
                ISRPENDING: u1,
                ISRPREEMPT: u1,
                reserved4: u1,
                PENDSTCLR: u1,
                PENDSTSET: u1,
                PENDSVCLR: u1,
                PENDSVSET: u1,
                reserved5: u1,
                reserved6: u1,
                NMIPENDSET: u1,
            }), base_address + 0xd04);

            /// address: 0xe000ed0c
            /// Application Interrupt and Reset Control Register
            pub const AIRCR = @intToPtr(*volatile Mmio(32, packed struct {
                reserved0: u1,
                VECTCLRACTIVE: u1,
                SYSRESETREQ: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                ENDIANESS: u1,
                VECTKEY: u16,
            }), base_address + 0xd0c);

            /// address: 0xe000ed10
            /// System Control Register
            pub const SCR = @intToPtr(*volatile Mmio(32, packed struct {
                reserved0: u1,
                SLEEPONEXIT: u1,
                SLEEPDEEP: u1,
                reserved1: u1,
                SEVONPEND: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
                padding22: u1,
                padding23: u1,
                padding24: u1,
                padding25: u1,
                padding26: u1,
            }), base_address + 0xd10);

            /// address: 0xe000ed14
            /// Configuration Control Register
            pub const CCR = @intToPtr(*volatile Mmio(32, packed struct {
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                UNALIGN_TRP: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                STKALIGN: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
            }), base_address + 0xd14);

            /// address: 0xe000ed1c
            /// System Handlers Priority Registers. [0] is RESERVED
            pub const SHP = @intToPtr(*volatile u32, base_address + 0xd1c);

            /// address: 0xe000ed24
            /// System Handler Control and State Register
            pub const SHCSR = @intToPtr(*volatile Mmio(32, packed struct {
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                SVCALLPENDED: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0xd24);
        };
    };

    /// Independent watchdog
    pub const IWDG = struct {
        pub const base_address = 0x40003000;

        /// address: 0x40003000
        /// Key register
        pub const KR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Key value (write only, read
            /// 0x0000)
            KEY: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0x40003004
        /// Prescaler register
        pub const PR = @intToPtr(*volatile MmioInt(32, u3), base_address + 0x4);

        /// address: 0x40003008
        /// Reload register
        pub const RLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Watchdog counter reload
            /// value
            RL: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x8);

        /// address: 0x4000300c
        /// Status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Watchdog prescaler value
            /// update
            PVU: u1,
            /// Watchdog counter reload value
            /// update
            RVU: u1,
            /// Watchdog counter window value
            /// update
            WVU: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0xc);

        /// address: 0x40003010
        /// Window register
        pub const WINR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Watchdog counter window
            /// value
            WIN: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x10);
    };

    /// System window watchdog
    pub const WWDG = struct {
        pub const base_address = 0x40002c00;

        /// address: 0x40002c00
        /// Control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 7-bit counter (MSB to LSB)
            T: u7,
            /// Activation bit
            WDGA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x40002c04
        /// Configuration register
        pub const CFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 7-bit window value
            W: u7,
            reserved0: u1,
            reserved1: u1,
            /// Early wakeup interrupt
            EWI: u1,
            reserved2: u1,
            /// Timer base
            WDGTB: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x4);

        /// address: 0x40002c08
        /// Status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Early wakeup interrupt
            /// flag
            EWIF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x8);
    };

    /// Flash
    pub const FLASH = struct {
        pub const base_address = 0x40022000;

        /// address: 0x40022000
        /// Access control register
        pub const ACR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Latency
            LATENCY: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Prefetch enable
            PRFTEN: u1,
            /// Instruction cache enable
            ICEN: u1,
            reserved5: u1,
            /// Instruction cache reset
            ICRST: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// Flash User area empty
            EMPTY: u1,
            reserved10: u1,
            /// Debug access software
            /// enable
            DBG_SWEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x0);

        /// address: 0x40022008
        /// Flash key register
        pub const KEYR = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x4002200c
        /// Option byte key register
        pub const OPTKEYR = @intToPtr(*volatile u32, base_address + 0xc);

        /// address: 0x40022010
        /// Status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// End of operation
            EOP: u1,
            /// Operation error
            OPERR: u1,
            reserved0: u1,
            /// Programming error
            PROGERR: u1,
            /// Write protected error
            WRPERR: u1,
            /// Programming alignment
            /// error
            PGAERR: u1,
            /// Size error
            SIZERR: u1,
            /// Programming sequence error
            PGSERR: u1,
            /// Fast programming data miss
            /// error
            MISERR: u1,
            /// Fast programming error
            FASTERR: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// PCROP read error
            RDERR: u1,
            /// Option and Engineering bits loading
            /// validity error
            OPTVERR: u1,
            /// Busy
            BSY: u1,
            reserved5: u1,
            /// Programming or erase configuration
            /// busy.
            CFGBSY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x10);

        /// address: 0x40022014
        /// Flash control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Programming
            PG: u1,
            /// Page erase
            PER: u1,
            /// Mass erase
            MER: u1,
            /// Page number
            PNB: u6,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Start
            STRT: u1,
            /// Options modification start
            OPTSTRT: u1,
            /// Fast programming
            FSTPG: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// End of operation interrupt
            /// enable
            EOPIE: u1,
            /// Error interrupt enable
            ERRIE: u1,
            /// PCROP read error interrupt
            /// enable
            RDERRIE: u1,
            /// Force the option byte
            /// loading
            OBL_LAUNCH: u1,
            /// Securable memory area protection
            /// enable
            SEC_PROT: u1,
            reserved12: u1,
            /// Options Lock
            OPTLOCK: u1,
            /// FLASH_CR Lock
            LOCK: u1,
        }), base_address + 0x14);

        /// address: 0x40022018
        /// Flash ECC register
        pub const ECCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ECC fail address
            ADDR_ECC: u14,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// ECC fail for Corrected ECC Error or
            /// Double ECC Error in info block
            SYSF_ECC: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// ECC correction interrupt
            /// enable
            ECCIE: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// ECC correction
            ECCC: u1,
            /// ECC detection
            ECCD: u1,
        }), base_address + 0x18);

        /// address: 0x40022020
        /// Flash option register
        pub const OPTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Read protection level
            RDP: u8,
            /// BOR reset Level
            BOREN: u1,
            /// These bits contain the VDD supply level
            /// threshold that activates the reset
            BORF_LEV: u2,
            /// These bits contain the VDD supply level
            /// threshold that releases the reset.
            BORR_LEV: u2,
            /// nRST_STOP
            nRST_STOP: u1,
            /// nRST_STDBY
            nRST_STDBY: u1,
            /// nRSTS_HDW
            nRSTS_HDW: u1,
            /// Independent watchdog
            /// selection
            IDWG_SW: u1,
            /// Independent watchdog counter freeze in
            /// Stop mode
            IWDG_STOP: u1,
            /// Independent watchdog counter freeze in
            /// Standby mode
            IWDG_STDBY: u1,
            /// Window watchdog selection
            WWDG_SW: u1,
            reserved0: u1,
            reserved1: u1,
            /// SRAM parity check control
            RAM_PARITY_CHECK: u1,
            reserved2: u1,
            /// nBOOT_SEL
            nBOOT_SEL: u1,
            /// Boot configuration
            nBOOT1: u1,
            /// nBOOT0 option bit
            nBOOT0: u1,
            /// NRST_MODE
            NRST_MODE: u2,
            /// Internal reset holder enable
            /// bit
            IRHEN: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x20);

        /// address: 0x40022024
        /// Flash PCROP zone A Start address
        /// register
        pub const PCROP1ASR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PCROP1A area start offset
            PCROP1A_STRT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x24);

        /// address: 0x40022028
        /// Flash PCROP zone A End address
        /// register
        pub const PCROP1AER = @intToPtr(*volatile Mmio(32, packed struct {
            /// PCROP1A area end offset
            PCROP1A_END: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            /// PCROP area preserved when RDP level
            /// decreased
            PCROP_RDP: u1,
        }), base_address + 0x28);

        /// address: 0x4002202c
        /// Flash WRP area A address
        /// register
        pub const WRP1AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// WRP area A start offset
            WRP1A_STRT: u6,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// WRP area A end offset
            WRP1A_END: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x2c);

        /// address: 0x40022030
        /// Flash WRP area B address
        /// register
        pub const WRP1BR = @intToPtr(*volatile Mmio(32, packed struct {
            /// WRP area B start offset
            WRP1B_STRT: u6,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// WRP area B end offset
            WRP1B_END: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x30);

        /// address: 0x40022034
        /// Flash PCROP zone B Start address
        /// register
        pub const PCROP1BSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PCROP1B area start offset
            PCROP1B_STRT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x34);

        /// address: 0x40022038
        /// Flash PCROP zone B End address
        /// register
        pub const PCROP1BER = @intToPtr(*volatile Mmio(32, packed struct {
            /// PCROP1B area end offset
            PCROP1B_END: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x38);

        /// address: 0x40022080
        /// Flash Security register
        pub const SECR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Securable memory area size
            SEC_SIZE: u7,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// used to force boot from user
            /// area
            BOOT_LOCK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x80);
    };

    /// Reset and clock control
    pub const RCC = struct {
        pub const base_address = 0x40021000;

        /// address: 0x40021000
        /// Clock control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// HSI16 clock enable
            HSION: u1,
            /// HSI16 always enable for peripheral
            /// kernels
            HSIKERON: u1,
            /// HSI16 clock ready flag
            HSIRDY: u1,
            /// HSI16 clock division
            /// factor
            HSIDIV: u3,
            reserved8: u1,
            reserved9: u1,
            /// HSE clock enable
            HSEON: u1,
            /// HSE clock ready flag
            HSERDY: u1,
            /// HSE crystal oscillator
            /// bypass
            HSEBYP: u1,
            /// Clock security system
            /// enable
            CSSON: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// PLL enable
            PLLON: u1,
            /// PLL clock ready flag
            PLLRDY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x0);

        /// address: 0x40021004
        /// Internal clock sources calibration
        /// register
        pub const ICSCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// HSI16 clock calibration
            HSICAL: u8,
            /// HSI16 clock trimming
            HSITRIM: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x4);

        /// address: 0x40021008
        /// Clock configuration register
        pub const CFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// System clock switch
            SW: u3,
            /// System clock switch status
            SWS: u3,
            reserved0: u1,
            reserved1: u1,
            /// AHB prescaler
            HPRE: u4,
            /// APB prescaler
            PPRE: u3,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// Microcontroller clock
            /// output
            MCOSEL: u3,
            reserved11: u1,
            /// Microcontroller clock output
            /// prescaler
            MCOPRE: u3,
            padding0: u1,
        }), base_address + 0x8);

        /// address: 0x4002100c
        /// PLL configuration register
        pub const PLLSYSCFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLL input clock source
            PLLSRC: u2,
            reserved0: u1,
            reserved1: u1,
            /// Division factor M of the PLL input clock
            /// divider
            PLLM: u3,
            reserved2: u1,
            /// PLL frequency multiplication factor
            /// N
            PLLN: u7,
            reserved3: u1,
            /// PLLPCLK clock output
            /// enable
            PLLPEN: u1,
            /// PLL VCO division factor P for PLLPCLK
            /// clock output
            PLLP: u5,
            reserved4: u1,
            reserved5: u1,
            /// PLLQCLK clock output
            /// enable
            PLLQEN: u1,
            /// PLL VCO division factor Q for PLLQCLK
            /// clock output
            PLLQ: u3,
            /// PLLRCLK clock output
            /// enable
            PLLREN: u1,
            /// PLL VCO division factor R for PLLRCLK
            /// clock output
            PLLR: u3,
        }), base_address + 0xc);

        /// address: 0x40021018
        /// Clock interrupt enable
        /// register
        pub const CIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// LSI ready interrupt enable
            LSIRDYIE: u1,
            /// LSE ready interrupt enable
            LSERDYIE: u1,
            reserved0: u1,
            /// HSI ready interrupt enable
            HSIRDYIE: u1,
            /// HSE ready interrupt enable
            HSERDYIE: u1,
            /// PLL ready interrupt enable
            PLLSYSRDYIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x18);

        /// address: 0x4002101c
        /// Clock interrupt flag register
        pub const CIFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// LSI ready interrupt flag
            LSIRDYF: u1,
            /// LSE ready interrupt flag
            LSERDYF: u1,
            reserved0: u1,
            /// HSI ready interrupt flag
            HSIRDYF: u1,
            /// HSE ready interrupt flag
            HSERDYF: u1,
            /// PLL ready interrupt flag
            PLLSYSRDYF: u1,
            reserved1: u1,
            reserved2: u1,
            /// Clock security system interrupt
            /// flag
            CSSF: u1,
            /// LSE Clock security system interrupt
            /// flag
            LSECSSF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x1c);

        /// address: 0x40021020
        /// Clock interrupt clear register
        pub const CICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// LSI ready interrupt clear
            LSIRDYC: u1,
            /// LSE ready interrupt clear
            LSERDYC: u1,
            reserved0: u1,
            /// HSI ready interrupt clear
            HSIRDYC: u1,
            /// HSE ready interrupt clear
            HSERDYC: u1,
            /// PLL ready interrupt clear
            PLLSYSRDYC: u1,
            reserved1: u1,
            reserved2: u1,
            /// Clock security system interrupt
            /// clear
            CSSC: u1,
            /// LSE Clock security system interrupt
            /// clear
            LSECSSC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x20);

        /// address: 0x40021028
        /// AHB peripheral reset register
        pub const AHBRSTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA1 reset
            DMARST: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// FLITF reset
            FLASHRST: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// CRC reset
            CRCRST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x28);

        /// address: 0x40021024
        /// GPIO reset register
        pub const IOPRSTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// I/O port A reset
            IOPARST: u1,
            /// I/O port B reset
            IOPBRST: u1,
            /// I/O port C reset
            IOPCRST: u1,
            /// I/O port D reset
            IOPDRST: u1,
            reserved0: u1,
            /// I/O port F reset
            IOPFRST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x24);

        /// address: 0x4002102c
        /// APB peripheral reset register
        /// 1
        pub const APBRSTR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TIM2 timer reset
            TIM2RST: u1,
            /// TIM3 timer reset
            TIM3RST: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// SPI2 reset
            SPI2RST: u1,
            reserved12: u1,
            reserved13: u1,
            /// USART2 reset
            USART2RST: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// I2C1 reset
            I2C1RST: u1,
            /// I2C2 reset
            I2C2RST: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// Debug support reset
            DBGRST: u1,
            /// Power interface reset
            PWRRST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x2c);

        /// address: 0x40021030
        /// APB peripheral reset register
        /// 2
        pub const APBRSTR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SYSCFG, COMP and VREFBUF
            /// reset
            SYSCFGRST: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// TIM1 timer reset
            TIM1RST: u1,
            /// SPI1 reset
            SPI1RST: u1,
            reserved10: u1,
            /// USART1 reset
            USART1RST: u1,
            /// TIM14 timer reset
            TIM14RST: u1,
            reserved11: u1,
            /// TIM16 timer reset
            TIM16RST: u1,
            /// TIM17 timer reset
            TIM17RST: u1,
            reserved12: u1,
            /// ADC reset
            ADCRST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x30);

        /// address: 0x40021034
        /// GPIO clock enable register
        pub const IOPENR = @intToPtr(*volatile Mmio(32, packed struct {
            /// I/O port A clock enable
            IOPAEN: u1,
            /// I/O port B clock enable
            IOPBEN: u1,
            /// I/O port C clock enable
            IOPCEN: u1,
            /// I/O port D clock enable
            IOPDEN: u1,
            reserved0: u1,
            /// I/O port F clock enable
            IOPFEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x34);

        /// address: 0x40021038
        /// AHB peripheral clock enable
        /// register
        pub const AHBENR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA clock enable
            DMAEN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Flash memory interface clock
            /// enable
            FLASHEN: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// CRC clock enable
            CRCEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x38);

        /// address: 0x4002103c
        /// APB peripheral clock enable register
        /// 1
        pub const APBENR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TIM2 timer clock enable
            TIM2EN: u1,
            /// TIM3 timer clock enable
            TIM3EN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// RTC APB clock enable
            RTCAPBEN: u1,
            /// WWDG clock enable
            WWDGEN: u1,
            reserved8: u1,
            reserved9: u1,
            /// SPI2 clock enable
            SPI2EN: u1,
            reserved10: u1,
            reserved11: u1,
            /// USART2 clock enable
            USART2EN: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// I2C1 clock enable
            I2C1EN: u1,
            /// I2C2 clock enable
            I2C2EN: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            /// Debug support clock enable
            DBGEN: u1,
            /// Power interface clock
            /// enable
            PWREN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x3c);

        /// address: 0x40021040
        /// APB peripheral clock enable register
        /// 2
        pub const APBENR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SYSCFG, COMP and VREFBUF clock
            /// enable
            SYSCFGEN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// TIM1 timer clock enable
            TIM1EN: u1,
            /// SPI1 clock enable
            SPI1EN: u1,
            reserved10: u1,
            /// USART1 clock enable
            USART1EN: u1,
            /// TIM14 timer clock enable
            TIM14EN: u1,
            reserved11: u1,
            /// TIM16 timer clock enable
            TIM16EN: u1,
            /// TIM16 timer clock enable
            TIM17EN: u1,
            reserved12: u1,
            /// ADC clock enable
            ADCEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x40);

        /// address: 0x40021044
        /// GPIO in Sleep mode clock enable
        /// register
        pub const IOPSMENR = @intToPtr(*volatile Mmio(32, packed struct {
            /// I/O port A clock enable during Sleep
            /// mode
            IOPASMEN: u1,
            /// I/O port B clock enable during Sleep
            /// mode
            IOPBSMEN: u1,
            /// I/O port C clock enable during Sleep
            /// mode
            IOPCSMEN: u1,
            /// I/O port D clock enable during Sleep
            /// mode
            IOPDSMEN: u1,
            reserved0: u1,
            /// I/O port F clock enable during Sleep
            /// mode
            IOPFSMEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x44);

        /// address: 0x40021048
        /// AHB peripheral clock enable in Sleep mode
        /// register
        pub const AHBSMENR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA clock enable during Sleep
            /// mode
            DMASMEN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Flash memory interface clock enable
            /// during Sleep mode
            FLASHSMEN: u1,
            /// SRAM clock enable during Sleep
            /// mode
            SRAMSMEN: u1,
            reserved7: u1,
            reserved8: u1,
            /// CRC clock enable during Sleep
            /// mode
            CRCSMEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x48);

        /// address: 0x4002104c
        /// APB peripheral clock enable in Sleep mode
        /// register 1
        pub const APBSMENR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TIM2 timer clock enable during Sleep
            /// mode
            TIM2SMEN: u1,
            /// TIM3 timer clock enable during Sleep
            /// mode
            TIM3SMEN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// RTC APB clock enable during Sleep
            /// mode
            RTCAPBSMEN: u1,
            /// WWDG clock enable during Sleep
            /// mode
            WWDGSMEN: u1,
            reserved8: u1,
            reserved9: u1,
            /// SPI2 clock enable during Sleep
            /// mode
            SPI2SMEN: u1,
            reserved10: u1,
            reserved11: u1,
            /// USART2 clock enable during Sleep
            /// mode
            USART2SMEN: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// I2C1 clock enable during Sleep
            /// mode
            I2C1SMEN: u1,
            /// I2C2 clock enable during Sleep
            /// mode
            I2C2SMEN: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            /// Debug support clock enable during Sleep
            /// mode
            DBGSMEN: u1,
            /// Power interface clock enable during
            /// Sleep mode
            PWRSMEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x4c);

        /// address: 0x40021050
        /// APB peripheral clock enable in Sleep mode
        /// register 2
        pub const APBSMENR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SYSCFG, COMP and VREFBUF clock enable
            /// during Sleep mode
            SYSCFGSMEN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// TIM1 timer clock enable during Sleep
            /// mode
            TIM1SMEN: u1,
            /// SPI1 clock enable during Sleep
            /// mode
            SPI1SMEN: u1,
            reserved10: u1,
            /// USART1 clock enable during Sleep
            /// mode
            USART1SMEN: u1,
            /// TIM14 timer clock enable during Sleep
            /// mode
            TIM14SMEN: u1,
            reserved11: u1,
            /// TIM16 timer clock enable during Sleep
            /// mode
            TIM16SMEN: u1,
            /// TIM16 timer clock enable during Sleep
            /// mode
            TIM17SMEN: u1,
            reserved12: u1,
            /// ADC clock enable during Sleep
            /// mode
            ADCSMEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x50);

        /// address: 0x40021054
        /// Peripherals independent clock configuration
        /// register
        pub const CCIPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// USART1 clock source
            /// selection
            USART1SEL: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// I2C1 clock source
            /// selection
            I2C1SEL: u2,
            /// I2S1 clock source
            /// selection
            I2S2SEL: u2,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// TIM1 clock source
            /// selection
            TIM1SEL: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            /// RNG clock source selection
            RNGSEL: u2,
            /// Division factor of RNG clock
            /// divider
            RNGDIV: u2,
            /// ADCs clock source
            /// selection
            ADCSEL: u2,
        }), base_address + 0x54);

        /// address: 0x4002105c
        /// RTC domain control register
        pub const BDCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// LSE oscillator enable
            LSEON: u1,
            /// LSE oscillator ready
            LSERDY: u1,
            /// LSE oscillator bypass
            LSEBYP: u1,
            /// LSE oscillator drive
            /// capability
            LSEDRV: u2,
            /// CSS on LSE enable
            LSECSSON: u1,
            /// CSS on LSE failure
            /// Detection
            LSECSSD: u1,
            reserved0: u1,
            /// RTC clock source selection
            RTCSEL: u2,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// RTC clock enable
            RTCEN: u1,
            /// RTC domain software reset
            BDRST: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// Low-speed clock output (LSCO)
            /// enable
            LSCOEN: u1,
            /// Low-speed clock output
            /// selection
            LSCOSEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x5c);

        /// address: 0x40021060
        /// Control/status register
        pub const CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// LSI oscillator enable
            LSION: u1,
            /// LSI oscillator ready
            LSIRDY: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// Remove reset flags
            RMVF: u1,
            reserved21: u1,
            /// Option byte loader reset
            /// flag
            OBLRSTF: u1,
            /// Pin reset flag
            PINRSTF: u1,
            /// BOR or POR/PDR flag
            PWRRSTF: u1,
            /// Software reset flag
            SFTRSTF: u1,
            /// Independent window watchdog reset
            /// flag
            IWDGRSTF: u1,
            /// Window watchdog reset flag
            WWDGRSTF: u1,
            /// Low-power reset flag
            LPWRRSTF: u1,
        }), base_address + 0x60);
    };

    /// Power control
    pub const PWR = struct {
        pub const base_address = 0x40007000;

        /// address: 0x40007000
        /// Power control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low-power mode selection
            LPMS: u3,
            /// Flash memory powered down during Stop
            /// mode
            FPD_STOP: u1,
            /// Flash memory powered down during
            /// Low-power run mode
            FPD_LPRUN: u1,
            /// Flash memory powered down during
            /// Low-power sleep mode
            FPD_LPSLP: u1,
            reserved0: u1,
            reserved1: u1,
            /// Disable backup domain write
            /// protection
            DBP: u1,
            /// Voltage scaling range
            /// selection
            VOS: u2,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Low-power run
            LPR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x0);

        /// address: 0x40007004
        /// Power control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Power voltage detector
            /// enable
            PVDE: u1,
            /// Power voltage detector falling threshold
            /// selection
            PVDFT: u3,
            /// Power voltage detector rising threshold
            /// selection
            PVDRT: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x4);

        /// address: 0x40007008
        /// Power control register 3
        pub const CR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable Wakeup pin WKUP1
            EWUP1: u1,
            /// Enable Wakeup pin WKUP2
            EWUP2: u1,
            reserved0: u1,
            /// Enable Wakeup pin WKUP4
            EWUP4: u1,
            /// Enable WKUP5 wakeup pin
            EWUP5: u1,
            /// Enable WKUP6 wakeup pin
            EWUP6: u1,
            reserved1: u1,
            reserved2: u1,
            /// SRAM retention in Standby
            /// mode
            RRS: u1,
            /// Enable the periodical sampling mode for
            /// PDR detection
            ULPEN: u1,
            /// Apply pull-up and pull-down
            /// configuration
            APC: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Enable internal wakeup
            /// line
            EIWUL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4000700c
        /// Power control register 4
        pub const CR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Wakeup pin WKUP1 polarity
            WP1: u1,
            /// Wakeup pin WKUP2 polarity
            WP2: u1,
            reserved0: u1,
            /// Wakeup pin WKUP4 polarity
            WP4: u1,
            /// Wakeup pin WKUP5 polarity
            WP5: u1,
            /// WKUP6 wakeup pin polarity
            WP6: u1,
            reserved1: u1,
            reserved2: u1,
            /// VBAT battery charging
            /// enable
            VBE: u1,
            /// VBAT battery charging resistor
            /// selection
            VBRS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0xc);

        /// address: 0x40007010
        /// Power status register 1
        pub const SR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Wakeup flag 1
            WUF1: u1,
            /// Wakeup flag 2
            WUF2: u1,
            reserved0: u1,
            /// Wakeup flag 4
            WUF4: u1,
            /// Wakeup flag 5
            WUF5: u1,
            /// Wakeup flag 6
            WUF6: u1,
            reserved1: u1,
            reserved2: u1,
            /// Standby flag
            SBF: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Wakeup flag internal
            WUFI: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40007014
        /// Power status register 2
        pub const SR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Flash ready flag
            FLASH_RDY: u1,
            /// Low-power regulator
            /// started
            REGLPS: u1,
            /// Low-power regulator flag
            REGLPF: u1,
            /// Voltage scaling flag
            VOSF: u1,
            /// Power voltage detector
            /// output
            PVDO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x14);

        /// address: 0x40007018
        /// Power status clear register
        pub const SCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear wakeup flag 1
            CWUF1: u1,
            /// Clear wakeup flag 2
            CWUF2: u1,
            reserved0: u1,
            /// Clear wakeup flag 4
            CWUF4: u1,
            /// Clear wakeup flag 5
            CWUF5: u1,
            /// Clear wakeup flag 6
            CWUF6: u1,
            reserved1: u1,
            reserved2: u1,
            /// Clear standby flag
            CSBF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x18);

        /// address: 0x40007020
        /// Power Port A pull-up control
        /// register
        pub const PUCRA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port A pull-up bit y
            /// (y=0..15)
            PU0: u1,
            /// Port A pull-up bit y
            /// (y=0..15)
            PU1: u1,
            /// Port A pull-up bit y
            /// (y=0..15)
            PU2: u1,
            /// Port A pull-up bit y
            /// (y=0..15)
            PU3: u1,
            /// Port A pull-up bit y
            /// (y=0..15)
            PU4: u1,
            /// Port A pull-up bit y
            /// (y=0..15)
            PU5: u1,
            /// Port A pull-up bit y
            /// (y=0..15)
            PU6: u1,
            /// Port A pull-up bit y
            /// (y=0..15)
            PU7: u1,
            /// Port A pull-up bit y
            /// (y=0..15)
            PU8: u1,
            /// Port A pull-up bit y
            /// (y=0..15)
            PU9: u1,
            /// Port A pull-up bit y
            /// (y=0..15)
            PU10: u1,
            /// Port A pull-up bit y
            /// (y=0..15)
            PU11: u1,
            /// Port A pull-up bit y
            /// (y=0..15)
            PU12: u1,
            /// Port A pull-up bit y
            /// (y=0..15)
            PU13: u1,
            /// Port A pull-up bit y
            /// (y=0..15)
            PU14: u1,
            /// Port A pull-up bit y
            /// (y=0..15)
            PU15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x20);

        /// address: 0x40007024
        /// Power Port A pull-down control
        /// register
        pub const PDCRA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port A pull-down bit y
            /// (y=0..15)
            PD0: u1,
            /// Port A pull-down bit y
            /// (y=0..15)
            PD1: u1,
            /// Port A pull-down bit y
            /// (y=0..15)
            PD2: u1,
            /// Port A pull-down bit y
            /// (y=0..15)
            PD3: u1,
            /// Port A pull-down bit y
            /// (y=0..15)
            PD4: u1,
            /// Port A pull-down bit y
            /// (y=0..15)
            PD5: u1,
            /// Port A pull-down bit y
            /// (y=0..15)
            PD6: u1,
            /// Port A pull-down bit y
            /// (y=0..15)
            PD7: u1,
            /// Port A pull-down bit y
            /// (y=0..15)
            PD8: u1,
            /// Port A pull-down bit y
            /// (y=0..15)
            PD9: u1,
            /// Port A pull-down bit y
            /// (y=0..15)
            PD10: u1,
            /// Port A pull-down bit y
            /// (y=0..15)
            PD11: u1,
            /// Port A pull-down bit y
            /// (y=0..15)
            PD12: u1,
            /// Port A pull-down bit y
            /// (y=0..15)
            PD13: u1,
            /// Port A pull-down bit y
            /// (y=0..15)
            PD14: u1,
            /// Port A pull-down bit y
            /// (y=0..15)
            PD15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x24);

        /// address: 0x40007028
        /// Power Port B pull-up control
        /// register
        pub const PUCRB = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port B pull-up bit y
            /// (y=0..15)
            PU0: u1,
            /// Port B pull-up bit y
            /// (y=0..15)
            PU1: u1,
            /// Port B pull-up bit y
            /// (y=0..15)
            PU2: u1,
            /// Port B pull-up bit y
            /// (y=0..15)
            PU3: u1,
            /// Port B pull-up bit y
            /// (y=0..15)
            PU4: u1,
            /// Port B pull-up bit y
            /// (y=0..15)
            PU5: u1,
            /// Port B pull-up bit y
            /// (y=0..15)
            PU6: u1,
            /// Port B pull-up bit y
            /// (y=0..15)
            PU7: u1,
            /// Port B pull-up bit y
            /// (y=0..15)
            PU8: u1,
            /// Port B pull-up bit y
            /// (y=0..15)
            PU9: u1,
            /// Port B pull-up bit y
            /// (y=0..15)
            PU10: u1,
            /// Port B pull-up bit y
            /// (y=0..15)
            PU11: u1,
            /// Port B pull-up bit y
            /// (y=0..15)
            PU12: u1,
            /// Port B pull-up bit y
            /// (y=0..15)
            PU13: u1,
            /// Port B pull-up bit y
            /// (y=0..15)
            PU14: u1,
            /// Port B pull-up bit y
            /// (y=0..15)
            PU15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);

        /// address: 0x4000702c
        /// Power Port B pull-down control
        /// register
        pub const PDCRB = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port B pull-down bit y
            /// (y=0..15)
            PD0: u1,
            /// Port B pull-down bit y
            /// (y=0..15)
            PD1: u1,
            /// Port B pull-down bit y
            /// (y=0..15)
            PD2: u1,
            /// Port B pull-down bit y
            /// (y=0..15)
            PD3: u1,
            /// Port B pull-down bit y
            /// (y=0..15)
            PD4: u1,
            /// Port B pull-down bit y
            /// (y=0..15)
            PD5: u1,
            /// Port B pull-down bit y
            /// (y=0..15)
            PD6: u1,
            /// Port B pull-down bit y
            /// (y=0..15)
            PD7: u1,
            /// Port B pull-down bit y
            /// (y=0..15)
            PD8: u1,
            /// Port B pull-down bit y
            /// (y=0..15)
            PD9: u1,
            /// Port B pull-down bit y
            /// (y=0..15)
            PD10: u1,
            /// Port B pull-down bit y
            /// (y=0..15)
            PD11: u1,
            /// Port B pull-down bit y
            /// (y=0..15)
            PD12: u1,
            /// Port B pull-down bit y
            /// (y=0..15)
            PD13: u1,
            /// Port B pull-down bit y
            /// (y=0..15)
            PD14: u1,
            /// Port B pull-down bit y
            /// (y=0..15)
            PD15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x2c);

        /// address: 0x40007030
        /// Power Port C pull-up control
        /// register
        pub const PUCRC = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Port C pull-up bit y
            /// (y=0..15)
            PU6: u1,
            /// Port C pull-up bit y
            /// (y=0..15)
            PU7: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// Port C pull-up bit y
            /// (y=0..15)
            PU13: u1,
            /// Port C pull-up bit y
            /// (y=0..15)
            PU14: u1,
            /// Port C pull-up bit y
            /// (y=0..15)
            PU15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x30);

        /// address: 0x40007034
        /// Power Port C pull-down control
        /// register
        pub const PDCRC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port C pull-down bit y
            /// (y=0..15)
            PD0: u1,
            /// Port C pull-down bit y
            /// (y=0..15)
            PD1: u1,
            /// Port C pull-down bit y
            /// (y=0..15)
            PD2: u1,
            /// Port C pull-down bit y
            /// (y=0..15)
            PD3: u1,
            /// Port C pull-down bit y
            /// (y=0..15)
            PD4: u1,
            /// Port C pull-down bit y
            /// (y=0..15)
            PD5: u1,
            /// Port C pull-down bit y
            /// (y=0..15)
            PD6: u1,
            /// Port C pull-down bit y
            /// (y=0..15)
            PD7: u1,
            /// Port C pull-down bit y
            /// (y=0..15)
            PD8: u1,
            /// Port C pull-down bit y
            /// (y=0..15)
            PD9: u1,
            /// Port C pull-down bit y
            /// (y=0..15)
            PD10: u1,
            /// Port C pull-down bit y
            /// (y=0..15)
            PD11: u1,
            /// Port C pull-down bit y
            /// (y=0..15)
            PD12: u1,
            /// Port C pull-down bit y
            /// (y=0..15)
            PD13: u1,
            /// Port C pull-down bit y
            /// (y=0..15)
            PD14: u1,
            /// Port C pull-down bit y
            /// (y=0..15)
            PD15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x34);

        /// address: 0x40007038
        /// Power Port D pull-up control
        /// register
        pub const PUCRD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port D pull-up bit y
            /// (y=0..15)
            PU0: u1,
            /// Port D pull-up bit y
            /// (y=0..15)
            PU1: u1,
            /// Port D pull-up bit y
            /// (y=0..15)
            PU2: u1,
            /// Port D pull-up bit y
            /// (y=0..15)
            PU3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x38);

        /// address: 0x4000703c
        /// Power Port D pull-down control
        /// register
        pub const PDCRD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port D pull-down bit y
            /// (y=0..15)
            PD0: u1,
            /// Port D pull-down bit y
            /// (y=0..15)
            PD1: u1,
            /// Port D pull-down bit y
            /// (y=0..15)
            PD2: u1,
            /// Port D pull-down bit y
            /// (y=0..15)
            PD3: u1,
            /// Port D pull-down bit y
            /// (y=0..15)
            PD4: u1,
            /// Port D pull-down bit y
            /// (y=0..15)
            PD5: u1,
            /// Port D pull-down bit y
            /// (y=0..15)
            PD6: u1,
            reserved0: u1,
            /// Port D pull-down bit y
            /// (y=0..15)
            PD8: u1,
            /// Port D pull-down bit y
            /// (y=0..15)
            PD9: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x3c);

        /// address: 0x40007048
        /// Power Port F pull-up control
        /// register
        pub const PUCRF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port F pull-up bit y
            /// (y=0..15)
            PU0: u1,
            /// Port F pull-up bit y
            /// (y=0..15)
            PU1: u1,
            /// Port F pull-up bit y
            /// (y=0..15)
            PU2: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x48);

        /// address: 0x4000704c
        /// Power Port F pull-down control
        /// register
        pub const PDCRF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port F pull-down bit y
            /// (y=0..15)
            PD0: u1,
            /// Port F pull-down bit y
            /// (y=0..15)
            PD1: u1,
            /// Port F pull-down bit y
            /// (y=0..15)
            PD2: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x4c);
    };

    /// DMA controller
    pub const DMA = struct {
        pub const base_address = 0x40020000;

        /// address: 0x40020000
        /// low interrupt status register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel global interrupt
            /// flag
            GIF0: u1,
            /// Channel transfer complete
            /// flag
            TCIF1: u1,
            /// Channel half transfer flag
            HTIF2: u1,
            /// Channel transfer error
            /// flag
            TEIF3: u1,
            /// Channel global interrupt
            /// flag
            GIF4: u1,
            /// Channel transfer complete
            /// flag
            TCIF5: u1,
            /// Channel half transfer flag
            HTIF6: u1,
            /// Channel transfer error
            /// flag
            TEIF7: u1,
            /// Channel global interrupt
            /// flag
            GIF8: u1,
            /// Channel transfer complete
            /// flag
            TCIF9: u1,
            /// Channel half transfer flag
            HTIF10: u1,
            /// Channel transfer error
            /// flag
            TEIF11: u1,
            /// Channel global interrupt
            /// flag
            GIF12: u1,
            /// Channel transfer complete
            /// flag
            TCIF13: u1,
            /// Channel half transfer flag
            HTIF14: u1,
            /// Channel transfer error
            /// flag
            TEIF15: u1,
            /// Channel global interrupt
            /// flag
            GIF16: u1,
            /// Channel transfer complete
            /// flag
            TCIF17: u1,
            /// Channel half transfer flag
            HTIF18: u1,
            /// Channel transfer error
            /// flag
            TEIF19: u1,
            /// Channel global interrupt
            /// flag
            GIF20: u1,
            /// Channel transfer complete
            /// flag
            TCIF21: u1,
            /// Channel half transfer flag
            HTIF22: u1,
            /// Channel transfer error
            /// flag
            TEIF23: u1,
            /// Channel global interrupt
            /// flag
            GIF24: u1,
            /// Channel transfer complete
            /// flag
            TCIF25: u1,
            /// Channel half transfer flag
            HTIF26: u1,
            /// Channel transfer error
            /// flag
            TEIF27: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x0);

        /// address: 0x40020004
        /// high interrupt status register
        pub const IFCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel global interrupt
            /// flag
            CGIF0: u1,
            /// Channel transfer complete
            /// flag
            CTCIF1: u1,
            /// Channel half transfer flag
            CHTIF2: u1,
            /// Channel transfer error
            /// flag
            CTEIF3: u1,
            /// Channel global interrupt
            /// flag
            CGIF4: u1,
            /// Channel transfer complete
            /// flag
            CTCIF5: u1,
            /// Channel half transfer flag
            CHTIF6: u1,
            /// Channel transfer error
            /// flag
            CTEIF7: u1,
            /// Channel global interrupt
            /// flag
            CGIF8: u1,
            /// Channel transfer complete
            /// flag
            CTCIF9: u1,
            /// Channel half transfer flag
            CHTIF10: u1,
            /// Channel transfer error
            /// flag
            CTEIF11: u1,
            /// Channel global interrupt
            /// flag
            CGIF12: u1,
            /// Channel transfer complete
            /// flag
            CTCIF13: u1,
            /// Channel half transfer flag
            CHTIF14: u1,
            /// Channel transfer error
            /// flag
            CTEIF15: u1,
            /// Channel global interrupt
            /// flag
            CGIF16: u1,
            /// Channel transfer complete
            /// flag
            CTCIF17: u1,
            /// Channel half transfer flag
            CHTIF18: u1,
            /// Channel transfer error
            /// flag
            CTEIF19: u1,
            /// Channel global interrupt
            /// flag
            CGIF20: u1,
            /// Channel transfer complete
            /// flag
            CTCIF21: u1,
            /// Channel half transfer flag
            CHTIF22: u1,
            /// Channel transfer error
            /// flag
            CTEIF23: u1,
            /// Channel global interrupt
            /// flag
            CGIF24: u1,
            /// Channel transfer complete
            /// flag
            CTCIF25: u1,
            /// Channel half transfer flag
            CHTIF26: u1,
            /// Channel transfer error
            /// flag
            CTEIF27: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x4);

        /// address: 0x40020008
        /// DMA channel x configuration
        /// register
        pub const CCR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x8);

        /// address: 0x4002001c
        /// DMA channel x configuration
        /// register
        pub const CCR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x1c);

        /// address: 0x40020030
        /// DMA channel x configuration
        /// register
        pub const CCR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x30);

        /// address: 0x40020044
        /// DMA channel x configuration
        /// register
        pub const CCR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x44);

        /// address: 0x40020058
        /// DMA channel x configuration
        /// register
        pub const CCR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x58);

        /// address: 0x4002000c
        /// DMA channel x number of data
        /// register
        pub const CNDTR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40020020
        /// DMA channel x number of data
        /// register
        pub const CNDTR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x20);

        /// address: 0x40020034
        /// DMA channel x configuration
        /// register
        pub const CNDTR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x34);

        /// address: 0x40020048
        /// DMA channel x configuration
        /// register
        pub const CNDTR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x48);

        /// address: 0x4002005c
        /// DMA channel x configuration
        /// register
        pub const CNDTR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x5c);

        /// address: 0x40020010
        /// DMA channel x peripheral address
        /// register
        pub const CPAR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x10);

        /// address: 0x40020024
        /// DMA channel x peripheral address
        /// register
        pub const CPAR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x24);

        /// address: 0x40020038
        /// DMA channel x peripheral address
        /// register
        pub const CPAR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x38);

        /// address: 0x4002004c
        /// DMA channel x peripheral address
        /// register
        pub const CPAR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x4c);

        /// address: 0x40020060
        /// DMA channel x peripheral address
        /// register
        pub const CPAR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x60);

        /// address: 0x40020014
        /// DMA channel x memory address
        /// register
        pub const CMAR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x14);

        /// address: 0x40020028
        /// DMA channel x memory address
        /// register
        pub const CMAR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x28);

        /// address: 0x4002003c
        /// DMA channel x memory address
        /// register
        pub const CMAR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x3c);

        /// address: 0x40020050
        /// DMA channel x memory address
        /// register
        pub const CMAR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x50);

        /// address: 0x40020064
        /// DMA channel x memory address
        /// register
        pub const CMAR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x64);
    };

    /// DMAMUX
    pub const DMAMUX = struct {
        pub const base_address = 0x40020800;

        /// address: 0x40020800
        /// DMAMux - DMA request line multiplexer
        /// channel x control register
        pub const C0CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input DMA request line
            /// selected
            DMAREQ_ID: u8,
            /// Interrupt enable at synchronization
            /// event overrun
            SOIE: u1,
            /// Event generation
            /// enable/disable
            EGE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Synchronous operating mode
            /// enable/disable
            SE: u1,
            /// Synchronization event type selector
            /// Defines the synchronization event on the selected
            /// synchronization input:
            SPOL: u2,
            /// Number of DMA requests to forward
            /// Defines the number of DMA requests forwarded before
            /// output event is generated. In synchronous mode, it
            /// also defines the number of DMA requests to forward
            /// after a synchronization event, then stop forwarding.
            /// The actual number of DMA requests forwarded is
            /// NBREQ+1. Note: This field can only be written when
            /// both SE and EGE bits are reset.
            NBREQ: u5,
            /// Synchronization input
            /// selected
            SYNC_ID: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x0);

        /// address: 0x40020804
        /// DMAMux - DMA request line multiplexer
        /// channel x control register
        pub const C1CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input DMA request line
            /// selected
            DMAREQ_ID: u8,
            /// Interrupt enable at synchronization
            /// event overrun
            SOIE: u1,
            /// Event generation
            /// enable/disable
            EGE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Synchronous operating mode
            /// enable/disable
            SE: u1,
            /// Synchronization event type selector
            /// Defines the synchronization event on the selected
            /// synchronization input:
            SPOL: u2,
            /// Number of DMA requests to forward
            /// Defines the number of DMA requests forwarded before
            /// output event is generated. In synchronous mode, it
            /// also defines the number of DMA requests to forward
            /// after a synchronization event, then stop forwarding.
            /// The actual number of DMA requests forwarded is
            /// NBREQ+1. Note: This field can only be written when
            /// both SE and EGE bits are reset.
            NBREQ: u5,
            /// Synchronization input
            /// selected
            SYNC_ID: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x4);

        /// address: 0x40020808
        /// DMAMux - DMA request line multiplexer
        /// channel x control register
        pub const C2CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input DMA request line
            /// selected
            DMAREQ_ID: u8,
            /// Interrupt enable at synchronization
            /// event overrun
            SOIE: u1,
            /// Event generation
            /// enable/disable
            EGE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Synchronous operating mode
            /// enable/disable
            SE: u1,
            /// Synchronization event type selector
            /// Defines the synchronization event on the selected
            /// synchronization input:
            SPOL: u2,
            /// Number of DMA requests to forward
            /// Defines the number of DMA requests forwarded before
            /// output event is generated. In synchronous mode, it
            /// also defines the number of DMA requests to forward
            /// after a synchronization event, then stop forwarding.
            /// The actual number of DMA requests forwarded is
            /// NBREQ+1. Note: This field can only be written when
            /// both SE and EGE bits are reset.
            NBREQ: u5,
            /// Synchronization input
            /// selected
            SYNC_ID: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x8);

        /// address: 0x4002080c
        /// DMAMux - DMA request line multiplexer
        /// channel x control register
        pub const C3CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input DMA request line
            /// selected
            DMAREQ_ID: u8,
            /// Interrupt enable at synchronization
            /// event overrun
            SOIE: u1,
            /// Event generation
            /// enable/disable
            EGE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Synchronous operating mode
            /// enable/disable
            SE: u1,
            /// Synchronization event type selector
            /// Defines the synchronization event on the selected
            /// synchronization input:
            SPOL: u2,
            /// Number of DMA requests to forward
            /// Defines the number of DMA requests forwarded before
            /// output event is generated. In synchronous mode, it
            /// also defines the number of DMA requests to forward
            /// after a synchronization event, then stop forwarding.
            /// The actual number of DMA requests forwarded is
            /// NBREQ+1. Note: This field can only be written when
            /// both SE and EGE bits are reset.
            NBREQ: u5,
            /// Synchronization input
            /// selected
            SYNC_ID: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0xc);

        /// address: 0x40020810
        /// DMAMux - DMA request line multiplexer
        /// channel x control register
        pub const C4CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input DMA request line
            /// selected
            DMAREQ_ID: u8,
            /// Interrupt enable at synchronization
            /// event overrun
            SOIE: u1,
            /// Event generation
            /// enable/disable
            EGE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Synchronous operating mode
            /// enable/disable
            SE: u1,
            /// Synchronization event type selector
            /// Defines the synchronization event on the selected
            /// synchronization input:
            SPOL: u2,
            /// Number of DMA requests to forward
            /// Defines the number of DMA requests forwarded before
            /// output event is generated. In synchronous mode, it
            /// also defines the number of DMA requests to forward
            /// after a synchronization event, then stop forwarding.
            /// The actual number of DMA requests forwarded is
            /// NBREQ+1. Note: This field can only be written when
            /// both SE and EGE bits are reset.
            NBREQ: u5,
            /// Synchronization input
            /// selected
            SYNC_ID: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x10);

        /// address: 0x40020814
        /// DMAMux - DMA request line multiplexer
        /// channel x control register
        pub const C5CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input DMA request line
            /// selected
            DMAREQ_ID: u8,
            /// Interrupt enable at synchronization
            /// event overrun
            SOIE: u1,
            /// Event generation
            /// enable/disable
            EGE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Synchronous operating mode
            /// enable/disable
            SE: u1,
            /// Synchronization event type selector
            /// Defines the synchronization event on the selected
            /// synchronization input:
            SPOL: u2,
            /// Number of DMA requests to forward
            /// Defines the number of DMA requests forwarded before
            /// output event is generated. In synchronous mode, it
            /// also defines the number of DMA requests to forward
            /// after a synchronization event, then stop forwarding.
            /// The actual number of DMA requests forwarded is
            /// NBREQ+1. Note: This field can only be written when
            /// both SE and EGE bits are reset.
            NBREQ: u5,
            /// Synchronization input
            /// selected
            SYNC_ID: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x14);

        /// address: 0x40020818
        /// DMAMux - DMA request line multiplexer
        /// channel x control register
        pub const C6CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input DMA request line
            /// selected
            DMAREQ_ID: u8,
            /// Interrupt enable at synchronization
            /// event overrun
            SOIE: u1,
            /// Event generation
            /// enable/disable
            EGE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Synchronous operating mode
            /// enable/disable
            SE: u1,
            /// Synchronization event type selector
            /// Defines the synchronization event on the selected
            /// synchronization input:
            SPOL: u2,
            /// Number of DMA requests to forward
            /// Defines the number of DMA requests forwarded before
            /// output event is generated. In synchronous mode, it
            /// also defines the number of DMA requests to forward
            /// after a synchronization event, then stop forwarding.
            /// The actual number of DMA requests forwarded is
            /// NBREQ+1. Note: This field can only be written when
            /// both SE and EGE bits are reset.
            NBREQ: u5,
            /// Synchronization input
            /// selected
            SYNC_ID: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x18);

        /// address: 0x40020900
        /// DMAMux - DMA request generator channel x
        /// control register
        pub const RG0CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA request trigger input
            /// selected
            SIG_ID: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Interrupt enable at trigger event
            /// overrun
            OIE: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// DMA request generator channel
            /// enable/disable
            GE: u1,
            /// DMA request generator trigger event type
            /// selection Defines the trigger event on the selected
            /// DMA request trigger input
            GPOL: u2,
            /// Number of DMA requests to generate
            /// Defines the number of DMA requests generated after a
            /// trigger event, then stop generating. The actual
            /// number of generated DMA requests is GNBREQ+1. Note:
            /// This field can only be written when GE bit is
            /// reset.
            GNBREQ: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x100);

        /// address: 0x40020904
        /// DMAMux - DMA request generator channel x
        /// control register
        pub const RG1CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA request trigger input
            /// selected
            SIG_ID: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Interrupt enable at trigger event
            /// overrun
            OIE: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// DMA request generator channel
            /// enable/disable
            GE: u1,
            /// DMA request generator trigger event type
            /// selection Defines the trigger event on the selected
            /// DMA request trigger input
            GPOL: u2,
            /// Number of DMA requests to generate
            /// Defines the number of DMA requests generated after a
            /// trigger event, then stop generating. The actual
            /// number of generated DMA requests is GNBREQ+1. Note:
            /// This field can only be written when GE bit is
            /// reset.
            GNBREQ: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x104);

        /// address: 0x40020908
        /// DMAMux - DMA request generator channel x
        /// control register
        pub const RG2CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA request trigger input
            /// selected
            SIG_ID: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Interrupt enable at trigger event
            /// overrun
            OIE: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// DMA request generator channel
            /// enable/disable
            GE: u1,
            /// DMA request generator trigger event type
            /// selection Defines the trigger event on the selected
            /// DMA request trigger input
            GPOL: u2,
            /// Number of DMA requests to generate
            /// Defines the number of DMA requests generated after a
            /// trigger event, then stop generating. The actual
            /// number of generated DMA requests is GNBREQ+1. Note:
            /// This field can only be written when GE bit is
            /// reset.
            GNBREQ: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x108);

        /// address: 0x4002090c
        /// DMAMux - DMA request generator channel x
        /// control register
        pub const RG3CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA request trigger input
            /// selected
            SIG_ID: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Interrupt enable at trigger event
            /// overrun
            OIE: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// DMA request generator channel
            /// enable/disable
            GE: u1,
            /// DMA request generator trigger event type
            /// selection Defines the trigger event on the selected
            /// DMA request trigger input
            GPOL: u2,
            /// Number of DMA requests to generate
            /// Defines the number of DMA requests generated after a
            /// trigger event, then stop generating. The actual
            /// number of generated DMA requests is GNBREQ+1. Note:
            /// This field can only be written when GE bit is
            /// reset.
            GNBREQ: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x10c);

        /// address: 0x40020940
        /// DMAMux - DMA request generator status
        /// register
        pub const RGSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Trigger event overrun flag The flag is
            /// set when a trigger event occurs on DMA request
            /// generator channel x, while the DMA request generator
            /// counter value is lower than GNBREQ. The flag is
            /// cleared by writing 1 to the corresponding COFx bit in
            /// DMAMUX_RGCFR register.
            OF: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x140);

        /// address: 0x40020944
        /// DMAMux - DMA request generator clear flag
        /// register
        pub const RGCFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear trigger event overrun flag Upon
            /// setting, this bit clears the corresponding overrun
            /// flag OFx in the DMAMUX_RGCSR register.
            COF: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x144);
    };

    /// General-purpose I/Os
    pub const GPIOA = struct {
        pub const base_address = 0x50000000;

        /// address: 0x50000000
        /// GPIO port mode register
        pub const MODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            MODER0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER15: u2,
        }), base_address + 0x0);

        /// address: 0x50000004
        /// GPIO port output type register
        pub const OTYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OT0: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT1: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT2: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT3: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT4: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT5: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT6: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT7: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT8: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT9: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT10: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT11: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT12: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT13: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT14: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x50000008
        /// GPIO port output speed
        /// register
        pub const OSPEEDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR15: u2,
        }), base_address + 0x8);

        /// address: 0x5000000c
        /// GPIO port pull-up/pull-down
        /// register
        pub const PUPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR15: u2,
        }), base_address + 0xc);

        /// address: 0x50000010
        /// GPIO port input data register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data (y =
            /// 0..15)
            IDR0: u1,
            /// Port input data (y =
            /// 0..15)
            IDR1: u1,
            /// Port input data (y =
            /// 0..15)
            IDR2: u1,
            /// Port input data (y =
            /// 0..15)
            IDR3: u1,
            /// Port input data (y =
            /// 0..15)
            IDR4: u1,
            /// Port input data (y =
            /// 0..15)
            IDR5: u1,
            /// Port input data (y =
            /// 0..15)
            IDR6: u1,
            /// Port input data (y =
            /// 0..15)
            IDR7: u1,
            /// Port input data (y =
            /// 0..15)
            IDR8: u1,
            /// Port input data (y =
            /// 0..15)
            IDR9: u1,
            /// Port input data (y =
            /// 0..15)
            IDR10: u1,
            /// Port input data (y =
            /// 0..15)
            IDR11: u1,
            /// Port input data (y =
            /// 0..15)
            IDR12: u1,
            /// Port input data (y =
            /// 0..15)
            IDR13: u1,
            /// Port input data (y =
            /// 0..15)
            IDR14: u1,
            /// Port input data (y =
            /// 0..15)
            IDR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x50000014
        /// GPIO port output data register
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data (y =
            /// 0..15)
            ODR0: u1,
            /// Port output data (y =
            /// 0..15)
            ODR1: u1,
            /// Port output data (y =
            /// 0..15)
            ODR2: u1,
            /// Port output data (y =
            /// 0..15)
            ODR3: u1,
            /// Port output data (y =
            /// 0..15)
            ODR4: u1,
            /// Port output data (y =
            /// 0..15)
            ODR5: u1,
            /// Port output data (y =
            /// 0..15)
            ODR6: u1,
            /// Port output data (y =
            /// 0..15)
            ODR7: u1,
            /// Port output data (y =
            /// 0..15)
            ODR8: u1,
            /// Port output data (y =
            /// 0..15)
            ODR9: u1,
            /// Port output data (y =
            /// 0..15)
            ODR10: u1,
            /// Port output data (y =
            /// 0..15)
            ODR11: u1,
            /// Port output data (y =
            /// 0..15)
            ODR12: u1,
            /// Port output data (y =
            /// 0..15)
            ODR13: u1,
            /// Port output data (y =
            /// 0..15)
            ODR14: u1,
            /// Port output data (y =
            /// 0..15)
            ODR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x50000018
        /// GPIO port bit set/reset
        /// register
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x set bit y (y=
            /// 0..15)
            BS0: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS1: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS2: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS3: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS4: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS5: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS6: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS7: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS8: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS9: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS10: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS11: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS12: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS13: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS14: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS15: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BR0: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR1: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR2: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR3: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR4: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR5: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR6: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR7: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR8: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR9: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR10: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR11: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR12: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR13: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR14: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR15: u1,
        }), base_address + 0x18);

        /// address: 0x5000001c
        /// GPIO port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x lock bit y (y=
            /// 0..15)
            LCK0: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK1: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK2: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK3: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK4: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK5: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK6: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK7: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK8: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK9: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK10: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK11: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK12: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK13: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK14: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK15: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x50000020
        /// GPIO alternate function low
        /// register
        pub const AFRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL0: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL1: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL2: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL3: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL4: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL5: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL6: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL7: u4,
        }), base_address + 0x20);

        /// address: 0x50000024
        /// GPIO alternate function high
        /// register
        pub const AFRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL8: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL9: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL10: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL11: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL12: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL13: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL14: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL15: u4,
        }), base_address + 0x24);

        /// address: 0x50000028
        /// port bit reset register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port Reset bit
            BR0: u1,
            /// Port Reset bit
            BR1: u1,
            /// Port Reset bit
            BR2: u1,
            /// Port Reset bit
            BR3: u1,
            /// Port Reset bit
            BR4: u1,
            /// Port Reset bit
            BR5: u1,
            /// Port Reset bit
            BR6: u1,
            /// Port Reset bit
            BR7: u1,
            /// Port Reset bit
            BR8: u1,
            /// Port Reset bit
            BR9: u1,
            /// Port Reset bit
            BR10: u1,
            /// Port Reset bit
            BR11: u1,
            /// Port Reset bit
            BR12: u1,
            /// Port Reset bit
            BR13: u1,
            /// Port Reset bit
            BR14: u1,
            /// Port Reset bit
            BR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);
    };

    /// General-purpose I/Os
    pub const GPIOB = struct {
        pub const base_address = 0x50000400;

        /// address: 0x50000400
        /// GPIO port mode register
        pub const MODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            MODER0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER15: u2,
        }), base_address + 0x0);

        /// address: 0x50000404
        /// GPIO port output type register
        pub const OTYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OT0: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT1: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT2: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT3: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT4: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT5: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT6: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT7: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT8: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT9: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT10: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT11: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT12: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT13: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT14: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x50000408
        /// GPIO port output speed
        /// register
        pub const OSPEEDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR15: u2,
        }), base_address + 0x8);

        /// address: 0x5000040c
        /// GPIO port pull-up/pull-down
        /// register
        pub const PUPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR15: u2,
        }), base_address + 0xc);

        /// address: 0x50000410
        /// GPIO port input data register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data (y =
            /// 0..15)
            IDR0: u1,
            /// Port input data (y =
            /// 0..15)
            IDR1: u1,
            /// Port input data (y =
            /// 0..15)
            IDR2: u1,
            /// Port input data (y =
            /// 0..15)
            IDR3: u1,
            /// Port input data (y =
            /// 0..15)
            IDR4: u1,
            /// Port input data (y =
            /// 0..15)
            IDR5: u1,
            /// Port input data (y =
            /// 0..15)
            IDR6: u1,
            /// Port input data (y =
            /// 0..15)
            IDR7: u1,
            /// Port input data (y =
            /// 0..15)
            IDR8: u1,
            /// Port input data (y =
            /// 0..15)
            IDR9: u1,
            /// Port input data (y =
            /// 0..15)
            IDR10: u1,
            /// Port input data (y =
            /// 0..15)
            IDR11: u1,
            /// Port input data (y =
            /// 0..15)
            IDR12: u1,
            /// Port input data (y =
            /// 0..15)
            IDR13: u1,
            /// Port input data (y =
            /// 0..15)
            IDR14: u1,
            /// Port input data (y =
            /// 0..15)
            IDR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x50000414
        /// GPIO port output data register
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data (y =
            /// 0..15)
            ODR0: u1,
            /// Port output data (y =
            /// 0..15)
            ODR1: u1,
            /// Port output data (y =
            /// 0..15)
            ODR2: u1,
            /// Port output data (y =
            /// 0..15)
            ODR3: u1,
            /// Port output data (y =
            /// 0..15)
            ODR4: u1,
            /// Port output data (y =
            /// 0..15)
            ODR5: u1,
            /// Port output data (y =
            /// 0..15)
            ODR6: u1,
            /// Port output data (y =
            /// 0..15)
            ODR7: u1,
            /// Port output data (y =
            /// 0..15)
            ODR8: u1,
            /// Port output data (y =
            /// 0..15)
            ODR9: u1,
            /// Port output data (y =
            /// 0..15)
            ODR10: u1,
            /// Port output data (y =
            /// 0..15)
            ODR11: u1,
            /// Port output data (y =
            /// 0..15)
            ODR12: u1,
            /// Port output data (y =
            /// 0..15)
            ODR13: u1,
            /// Port output data (y =
            /// 0..15)
            ODR14: u1,
            /// Port output data (y =
            /// 0..15)
            ODR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x50000418
        /// GPIO port bit set/reset
        /// register
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x set bit y (y=
            /// 0..15)
            BS0: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS1: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS2: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS3: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS4: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS5: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS6: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS7: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS8: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS9: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS10: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS11: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS12: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS13: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS14: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS15: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BR0: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR1: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR2: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR3: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR4: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR5: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR6: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR7: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR8: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR9: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR10: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR11: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR12: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR13: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR14: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR15: u1,
        }), base_address + 0x18);

        /// address: 0x5000041c
        /// GPIO port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x lock bit y (y=
            /// 0..15)
            LCK0: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK1: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK2: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK3: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK4: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK5: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK6: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK7: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK8: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK9: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK10: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK11: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK12: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK13: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK14: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK15: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x50000420
        /// GPIO alternate function low
        /// register
        pub const AFRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL0: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL1: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL2: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL3: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL4: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL5: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL6: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL7: u4,
        }), base_address + 0x20);

        /// address: 0x50000424
        /// GPIO alternate function high
        /// register
        pub const AFRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL8: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL9: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL10: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL11: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL12: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL13: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL14: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL15: u4,
        }), base_address + 0x24);

        /// address: 0x50000428
        /// port bit reset register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port Reset bit
            BR0: u1,
            /// Port Reset bit
            BR1: u1,
            /// Port Reset bit
            BR2: u1,
            /// Port Reset bit
            BR3: u1,
            /// Port Reset bit
            BR4: u1,
            /// Port Reset bit
            BR5: u1,
            /// Port Reset bit
            BR6: u1,
            /// Port Reset bit
            BR7: u1,
            /// Port Reset bit
            BR8: u1,
            /// Port Reset bit
            BR9: u1,
            /// Port Reset bit
            BR10: u1,
            /// Port Reset bit
            BR11: u1,
            /// Port Reset bit
            BR12: u1,
            /// Port Reset bit
            BR13: u1,
            /// Port Reset bit
            BR14: u1,
            /// Port Reset bit
            BR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);
    };
    pub const GPIOC = struct {
        pub const base_address = 0x50000800;

        /// address: 0x50000800
        /// GPIO port mode register
        pub const MODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            MODER0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER15: u2,
        }), base_address + 0x0);

        /// address: 0x50000804
        /// GPIO port output type register
        pub const OTYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OT0: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT1: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT2: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT3: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT4: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT5: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT6: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT7: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT8: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT9: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT10: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT11: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT12: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT13: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT14: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x50000808
        /// GPIO port output speed
        /// register
        pub const OSPEEDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR15: u2,
        }), base_address + 0x8);

        /// address: 0x5000080c
        /// GPIO port pull-up/pull-down
        /// register
        pub const PUPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR15: u2,
        }), base_address + 0xc);

        /// address: 0x50000810
        /// GPIO port input data register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data (y =
            /// 0..15)
            IDR0: u1,
            /// Port input data (y =
            /// 0..15)
            IDR1: u1,
            /// Port input data (y =
            /// 0..15)
            IDR2: u1,
            /// Port input data (y =
            /// 0..15)
            IDR3: u1,
            /// Port input data (y =
            /// 0..15)
            IDR4: u1,
            /// Port input data (y =
            /// 0..15)
            IDR5: u1,
            /// Port input data (y =
            /// 0..15)
            IDR6: u1,
            /// Port input data (y =
            /// 0..15)
            IDR7: u1,
            /// Port input data (y =
            /// 0..15)
            IDR8: u1,
            /// Port input data (y =
            /// 0..15)
            IDR9: u1,
            /// Port input data (y =
            /// 0..15)
            IDR10: u1,
            /// Port input data (y =
            /// 0..15)
            IDR11: u1,
            /// Port input data (y =
            /// 0..15)
            IDR12: u1,
            /// Port input data (y =
            /// 0..15)
            IDR13: u1,
            /// Port input data (y =
            /// 0..15)
            IDR14: u1,
            /// Port input data (y =
            /// 0..15)
            IDR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x50000814
        /// GPIO port output data register
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data (y =
            /// 0..15)
            ODR0: u1,
            /// Port output data (y =
            /// 0..15)
            ODR1: u1,
            /// Port output data (y =
            /// 0..15)
            ODR2: u1,
            /// Port output data (y =
            /// 0..15)
            ODR3: u1,
            /// Port output data (y =
            /// 0..15)
            ODR4: u1,
            /// Port output data (y =
            /// 0..15)
            ODR5: u1,
            /// Port output data (y =
            /// 0..15)
            ODR6: u1,
            /// Port output data (y =
            /// 0..15)
            ODR7: u1,
            /// Port output data (y =
            /// 0..15)
            ODR8: u1,
            /// Port output data (y =
            /// 0..15)
            ODR9: u1,
            /// Port output data (y =
            /// 0..15)
            ODR10: u1,
            /// Port output data (y =
            /// 0..15)
            ODR11: u1,
            /// Port output data (y =
            /// 0..15)
            ODR12: u1,
            /// Port output data (y =
            /// 0..15)
            ODR13: u1,
            /// Port output data (y =
            /// 0..15)
            ODR14: u1,
            /// Port output data (y =
            /// 0..15)
            ODR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x50000818
        /// GPIO port bit set/reset
        /// register
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x set bit y (y=
            /// 0..15)
            BS0: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS1: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS2: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS3: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS4: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS5: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS6: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS7: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS8: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS9: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS10: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS11: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS12: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS13: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS14: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS15: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BR0: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR1: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR2: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR3: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR4: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR5: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR6: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR7: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR8: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR9: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR10: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR11: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR12: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR13: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR14: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR15: u1,
        }), base_address + 0x18);

        /// address: 0x5000081c
        /// GPIO port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x lock bit y (y=
            /// 0..15)
            LCK0: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK1: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK2: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK3: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK4: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK5: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK6: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK7: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK8: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK9: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK10: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK11: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK12: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK13: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK14: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK15: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x50000820
        /// GPIO alternate function low
        /// register
        pub const AFRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL0: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL1: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL2: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL3: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL4: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL5: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL6: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL7: u4,
        }), base_address + 0x20);

        /// address: 0x50000824
        /// GPIO alternate function high
        /// register
        pub const AFRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL8: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL9: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL10: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL11: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL12: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL13: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL14: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL15: u4,
        }), base_address + 0x24);

        /// address: 0x50000828
        /// port bit reset register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port Reset bit
            BR0: u1,
            /// Port Reset bit
            BR1: u1,
            /// Port Reset bit
            BR2: u1,
            /// Port Reset bit
            BR3: u1,
            /// Port Reset bit
            BR4: u1,
            /// Port Reset bit
            BR5: u1,
            /// Port Reset bit
            BR6: u1,
            /// Port Reset bit
            BR7: u1,
            /// Port Reset bit
            BR8: u1,
            /// Port Reset bit
            BR9: u1,
            /// Port Reset bit
            BR10: u1,
            /// Port Reset bit
            BR11: u1,
            /// Port Reset bit
            BR12: u1,
            /// Port Reset bit
            BR13: u1,
            /// Port Reset bit
            BR14: u1,
            /// Port Reset bit
            BR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);
    };
    pub const GPIOD = struct {
        pub const base_address = 0x50000c00;

        /// address: 0x50000c00
        /// GPIO port mode register
        pub const MODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            MODER0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER15: u2,
        }), base_address + 0x0);

        /// address: 0x50000c04
        /// GPIO port output type register
        pub const OTYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OT0: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT1: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT2: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT3: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT4: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT5: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT6: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT7: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT8: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT9: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT10: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT11: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT12: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT13: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT14: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x50000c08
        /// GPIO port output speed
        /// register
        pub const OSPEEDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR15: u2,
        }), base_address + 0x8);

        /// address: 0x50000c0c
        /// GPIO port pull-up/pull-down
        /// register
        pub const PUPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR15: u2,
        }), base_address + 0xc);

        /// address: 0x50000c10
        /// GPIO port input data register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data (y =
            /// 0..15)
            IDR0: u1,
            /// Port input data (y =
            /// 0..15)
            IDR1: u1,
            /// Port input data (y =
            /// 0..15)
            IDR2: u1,
            /// Port input data (y =
            /// 0..15)
            IDR3: u1,
            /// Port input data (y =
            /// 0..15)
            IDR4: u1,
            /// Port input data (y =
            /// 0..15)
            IDR5: u1,
            /// Port input data (y =
            /// 0..15)
            IDR6: u1,
            /// Port input data (y =
            /// 0..15)
            IDR7: u1,
            /// Port input data (y =
            /// 0..15)
            IDR8: u1,
            /// Port input data (y =
            /// 0..15)
            IDR9: u1,
            /// Port input data (y =
            /// 0..15)
            IDR10: u1,
            /// Port input data (y =
            /// 0..15)
            IDR11: u1,
            /// Port input data (y =
            /// 0..15)
            IDR12: u1,
            /// Port input data (y =
            /// 0..15)
            IDR13: u1,
            /// Port input data (y =
            /// 0..15)
            IDR14: u1,
            /// Port input data (y =
            /// 0..15)
            IDR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x50000c14
        /// GPIO port output data register
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data (y =
            /// 0..15)
            ODR0: u1,
            /// Port output data (y =
            /// 0..15)
            ODR1: u1,
            /// Port output data (y =
            /// 0..15)
            ODR2: u1,
            /// Port output data (y =
            /// 0..15)
            ODR3: u1,
            /// Port output data (y =
            /// 0..15)
            ODR4: u1,
            /// Port output data (y =
            /// 0..15)
            ODR5: u1,
            /// Port output data (y =
            /// 0..15)
            ODR6: u1,
            /// Port output data (y =
            /// 0..15)
            ODR7: u1,
            /// Port output data (y =
            /// 0..15)
            ODR8: u1,
            /// Port output data (y =
            /// 0..15)
            ODR9: u1,
            /// Port output data (y =
            /// 0..15)
            ODR10: u1,
            /// Port output data (y =
            /// 0..15)
            ODR11: u1,
            /// Port output data (y =
            /// 0..15)
            ODR12: u1,
            /// Port output data (y =
            /// 0..15)
            ODR13: u1,
            /// Port output data (y =
            /// 0..15)
            ODR14: u1,
            /// Port output data (y =
            /// 0..15)
            ODR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x50000c18
        /// GPIO port bit set/reset
        /// register
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x set bit y (y=
            /// 0..15)
            BS0: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS1: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS2: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS3: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS4: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS5: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS6: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS7: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS8: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS9: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS10: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS11: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS12: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS13: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS14: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS15: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BR0: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR1: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR2: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR3: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR4: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR5: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR6: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR7: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR8: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR9: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR10: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR11: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR12: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR13: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR14: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR15: u1,
        }), base_address + 0x18);

        /// address: 0x50000c1c
        /// GPIO port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x lock bit y (y=
            /// 0..15)
            LCK0: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK1: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK2: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK3: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK4: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK5: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK6: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK7: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK8: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK9: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK10: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK11: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK12: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK13: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK14: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK15: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x50000c20
        /// GPIO alternate function low
        /// register
        pub const AFRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL0: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL1: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL2: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL3: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL4: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL5: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL6: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL7: u4,
        }), base_address + 0x20);

        /// address: 0x50000c24
        /// GPIO alternate function high
        /// register
        pub const AFRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL8: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL9: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL10: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL11: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL12: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL13: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL14: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL15: u4,
        }), base_address + 0x24);

        /// address: 0x50000c28
        /// port bit reset register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port Reset bit
            BR0: u1,
            /// Port Reset bit
            BR1: u1,
            /// Port Reset bit
            BR2: u1,
            /// Port Reset bit
            BR3: u1,
            /// Port Reset bit
            BR4: u1,
            /// Port Reset bit
            BR5: u1,
            /// Port Reset bit
            BR6: u1,
            /// Port Reset bit
            BR7: u1,
            /// Port Reset bit
            BR8: u1,
            /// Port Reset bit
            BR9: u1,
            /// Port Reset bit
            BR10: u1,
            /// Port Reset bit
            BR11: u1,
            /// Port Reset bit
            BR12: u1,
            /// Port Reset bit
            BR13: u1,
            /// Port Reset bit
            BR14: u1,
            /// Port Reset bit
            BR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);
    };
    pub const GPIOF = struct {
        pub const base_address = 0x50001400;

        /// address: 0x50001400
        /// GPIO port mode register
        pub const MODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            MODER0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER15: u2,
        }), base_address + 0x0);

        /// address: 0x50001404
        /// GPIO port output type register
        pub const OTYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OT0: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT1: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT2: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT3: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT4: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT5: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT6: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT7: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT8: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT9: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT10: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT11: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT12: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT13: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT14: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x50001408
        /// GPIO port output speed
        /// register
        pub const OSPEEDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR15: u2,
        }), base_address + 0x8);

        /// address: 0x5000140c
        /// GPIO port pull-up/pull-down
        /// register
        pub const PUPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR15: u2,
        }), base_address + 0xc);

        /// address: 0x50001410
        /// GPIO port input data register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data (y =
            /// 0..15)
            IDR0: u1,
            /// Port input data (y =
            /// 0..15)
            IDR1: u1,
            /// Port input data (y =
            /// 0..15)
            IDR2: u1,
            /// Port input data (y =
            /// 0..15)
            IDR3: u1,
            /// Port input data (y =
            /// 0..15)
            IDR4: u1,
            /// Port input data (y =
            /// 0..15)
            IDR5: u1,
            /// Port input data (y =
            /// 0..15)
            IDR6: u1,
            /// Port input data (y =
            /// 0..15)
            IDR7: u1,
            /// Port input data (y =
            /// 0..15)
            IDR8: u1,
            /// Port input data (y =
            /// 0..15)
            IDR9: u1,
            /// Port input data (y =
            /// 0..15)
            IDR10: u1,
            /// Port input data (y =
            /// 0..15)
            IDR11: u1,
            /// Port input data (y =
            /// 0..15)
            IDR12: u1,
            /// Port input data (y =
            /// 0..15)
            IDR13: u1,
            /// Port input data (y =
            /// 0..15)
            IDR14: u1,
            /// Port input data (y =
            /// 0..15)
            IDR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x50001414
        /// GPIO port output data register
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data (y =
            /// 0..15)
            ODR0: u1,
            /// Port output data (y =
            /// 0..15)
            ODR1: u1,
            /// Port output data (y =
            /// 0..15)
            ODR2: u1,
            /// Port output data (y =
            /// 0..15)
            ODR3: u1,
            /// Port output data (y =
            /// 0..15)
            ODR4: u1,
            /// Port output data (y =
            /// 0..15)
            ODR5: u1,
            /// Port output data (y =
            /// 0..15)
            ODR6: u1,
            /// Port output data (y =
            /// 0..15)
            ODR7: u1,
            /// Port output data (y =
            /// 0..15)
            ODR8: u1,
            /// Port output data (y =
            /// 0..15)
            ODR9: u1,
            /// Port output data (y =
            /// 0..15)
            ODR10: u1,
            /// Port output data (y =
            /// 0..15)
            ODR11: u1,
            /// Port output data (y =
            /// 0..15)
            ODR12: u1,
            /// Port output data (y =
            /// 0..15)
            ODR13: u1,
            /// Port output data (y =
            /// 0..15)
            ODR14: u1,
            /// Port output data (y =
            /// 0..15)
            ODR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x50001418
        /// GPIO port bit set/reset
        /// register
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x set bit y (y=
            /// 0..15)
            BS0: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS1: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS2: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS3: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS4: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS5: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS6: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS7: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS8: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS9: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS10: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS11: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS12: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS13: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS14: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS15: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BR0: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR1: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR2: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR3: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR4: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR5: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR6: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR7: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR8: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR9: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR10: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR11: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR12: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR13: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR14: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR15: u1,
        }), base_address + 0x18);

        /// address: 0x5000141c
        /// GPIO port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x lock bit y (y=
            /// 0..15)
            LCK0: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK1: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK2: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK3: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK4: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK5: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK6: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK7: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK8: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK9: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK10: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK11: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK12: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK13: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK14: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK15: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x50001420
        /// GPIO alternate function low
        /// register
        pub const AFRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL0: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL1: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL2: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL3: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL4: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL5: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL6: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFSEL7: u4,
        }), base_address + 0x20);

        /// address: 0x50001424
        /// GPIO alternate function high
        /// register
        pub const AFRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL8: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL9: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL10: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL11: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL12: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL13: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL14: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFSEL15: u4,
        }), base_address + 0x24);

        /// address: 0x50001428
        /// port bit reset register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port Reset bit
            BR0: u1,
            /// Port Reset bit
            BR1: u1,
            /// Port Reset bit
            BR2: u1,
            /// Port Reset bit
            BR3: u1,
            /// Port Reset bit
            BR4: u1,
            /// Port Reset bit
            BR5: u1,
            /// Port Reset bit
            BR6: u1,
            /// Port Reset bit
            BR7: u1,
            /// Port Reset bit
            BR8: u1,
            /// Port Reset bit
            BR9: u1,
            /// Port Reset bit
            BR10: u1,
            /// Port Reset bit
            BR11: u1,
            /// Port Reset bit
            BR12: u1,
            /// Port Reset bit
            BR13: u1,
            /// Port Reset bit
            BR14: u1,
            /// Port Reset bit
            BR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);
    };

    /// Cyclic redundancy check calculation
    /// unit
    pub const CRC = struct {
        pub const base_address = 0x40023000;

        /// address: 0x40023000
        /// Data register
        pub const DR = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x40023004
        /// Independent data register
        pub const IDR = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0x40023008
        /// Control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// RESET bit
            RESET: u1,
            reserved0: u1,
            reserved1: u1,
            /// Polynomial size
            POLYSIZE: u2,
            /// Reverse input data
            REV_IN: u2,
            /// Reverse output data
            REV_OUT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x8);

        /// address: 0x40023010
        /// Initial CRC value
        pub const INIT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Programmable initial CRC
            /// value
            CRC_INIT: u32,
        }), base_address + 0x10);

        /// address: 0x40023014
        /// polynomial
        pub const POL = @intToPtr(*volatile u32, base_address + 0x14);
    };

    /// External interrupt/event
    /// controller
    pub const EXTI = struct {
        pub const base_address = 0x40021800;

        /// address: 0x40021800
        /// EXTI rising trigger selection
        /// register
        pub const RTSR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            TR0: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            TR1: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            TR2: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            TR3: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            TR4: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            TR5: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            TR6: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            TR7: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            TR8: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            TR9: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            TR10: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            TR11: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            TR12: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            TR13: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            TR14: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            TR15: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            TR16: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x0);

        /// address: 0x40021804
        /// EXTI falling trigger selection
        /// register
        pub const FTSR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            TR0: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            TR1: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            TR2: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            TR3: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            TR4: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            TR5: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            TR6: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            TR7: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            TR8: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            TR9: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            TR10: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            TR11: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            TR12: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            TR13: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            TR14: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            TR15: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            TR16: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x4);

        /// address: 0x40021808
        /// EXTI software interrupt event
        /// register
        pub const SWIER1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            SWIER0: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            SWIER1: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            SWIER2: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            SWIER3: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            SWIER4: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            SWIER5: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            SWIER6: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            SWIER7: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            SWIER8: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            SWIER9: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            SWIER10: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            SWIER11: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            SWIER12: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            SWIER13: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            SWIER14: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            SWIER15: u1,
            /// Rising trigger event configuration bit
            /// of Configurable Event input
            SWIER16: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x8);

        /// address: 0x4002180c
        /// EXTI rising edge pending
        /// register
        pub const RPR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// configurable event inputs x rising edge
            /// Pending bit.
            RPIF0: u1,
            /// configurable event inputs x rising edge
            /// Pending bit.
            RPIF1: u1,
            /// configurable event inputs x rising edge
            /// Pending bit.
            RPIF2: u1,
            /// configurable event inputs x rising edge
            /// Pending bit.
            RPIF3: u1,
            /// configurable event inputs x rising edge
            /// Pending bit.
            RPIF4: u1,
            /// configurable event inputs x rising edge
            /// Pending bit
            RPIF5: u1,
            /// configurable event inputs x rising edge
            /// Pending bit.
            RPIF6: u1,
            /// configurable event inputs x rising edge
            /// Pending bit.
            RPIF7: u1,
            /// configurable event inputs x rising edge
            /// Pending bit.
            RPIF8: u1,
            /// configurable event inputs x rising edge
            /// Pending bit.
            RPIF9: u1,
            /// configurable event inputs x rising edge
            /// Pending bit.
            RPIF10: u1,
            /// configurable event inputs x rising edge
            /// Pending bit.
            RPIF11: u1,
            /// configurable event inputs x rising edge
            /// Pending bit.
            RPIF12: u1,
            /// configurable event inputs x rising edge
            /// Pending bit.
            RPIF13: u1,
            /// configurable event inputs x rising edge
            /// Pending bit.
            RPIF14: u1,
            /// configurable event inputs x rising edge
            /// Pending bit.
            RPIF15: u1,
            /// configurable event inputs x rising edge
            /// Pending bit.
            RPIF16: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0xc);

        /// address: 0x40021810
        /// EXTI falling edge pending
        /// register
        pub const FPR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// configurable event inputs x falling edge
            /// pending bit.
            FPIF0: u1,
            /// configurable event inputs x falling edge
            /// pending bit.
            FPIF1: u1,
            /// configurable event inputs x falling edge
            /// pending bit.
            FPIF2: u1,
            /// configurable event inputs x falling edge
            /// pending bit.
            FPIF3: u1,
            /// configurable event inputs x falling edge
            /// pending bit.
            FPIF4: u1,
            /// configurable event inputs x falling edge
            /// pending bit.
            FPIF5: u1,
            /// configurable event inputs x falling edge
            /// pending bit.
            FPIF6: u1,
            /// configurable event inputs x falling edge
            /// pending bit.
            FPIF7: u1,
            /// configurable event inputs x falling edge
            /// pending bit.
            FPIF8: u1,
            /// configurable event inputs x falling edge
            /// pending bit.
            FPIF9: u1,
            /// configurable event inputs x falling edge
            /// pending bit.
            FPIF10: u1,
            /// configurable event inputs x falling edge
            /// pending bit.
            FPIF11: u1,
            /// configurable event inputs x falling edge
            /// pending bit.
            FPIF12: u1,
            /// configurable event inputs x falling edge
            /// pending bit.
            FPIF13: u1,
            /// configurable event inputs x falling edge
            /// pending bit.
            FPIF14: u1,
            /// configurable event inputs x falling edge
            /// pending bit.
            FPIF15: u1,
            /// configurable event inputs x falling edge
            /// pending bit.
            FPIF16: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x10);

        /// address: 0x40021860
        /// EXTI external interrupt selection
        /// register
        pub const EXTICR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// GPIO port selection
            EXTI0_7: u8,
            /// GPIO port selection
            EXTI8_15: u8,
            /// GPIO port selection
            EXTI16_23: u8,
            /// GPIO port selection
            EXTI24_31: u8,
        }), base_address + 0x60);

        /// address: 0x40021864
        /// EXTI external interrupt selection
        /// register
        pub const EXTICR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// GPIO port selection
            EXTI0_7: u8,
            /// GPIO port selection
            EXTI8_15: u8,
            /// GPIO port selection
            EXTI16_23: u8,
            /// GPIO port selection
            EXTI24_31: u8,
        }), base_address + 0x64);

        /// address: 0x40021868
        /// EXTI external interrupt selection
        /// register
        pub const EXTICR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// GPIO port selection
            EXTI0_7: u8,
            /// GPIO port selection
            EXTI8_15: u8,
            /// GPIO port selection
            EXTI16_23: u8,
            /// GPIO port selection
            EXTI24_31: u8,
        }), base_address + 0x68);

        /// address: 0x4002186c
        /// EXTI external interrupt selection
        /// register
        pub const EXTICR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// GPIO port selection
            EXTI0_7: u8,
            /// GPIO port selection
            EXTI8_15: u8,
            /// GPIO port selection
            EXTI16_23: u8,
            /// GPIO port selection
            EXTI24_31: u8,
        }), base_address + 0x6c);

        /// address: 0x40021880
        /// EXTI CPU wakeup with interrupt mask
        /// register
        pub const IMR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// CPU wakeup with interrupt mask on event
            /// input
            IM0: u1,
            /// CPU wakeup with interrupt mask on event
            /// input
            IM1: u1,
            /// CPU wakeup with interrupt mask on event
            /// input
            IM2: u1,
            /// CPU wakeup with interrupt mask on event
            /// input
            IM3: u1,
            /// CPU wakeup with interrupt mask on event
            /// input
            IM4: u1,
            /// CPU wakeup with interrupt mask on event
            /// input
            IM5: u1,
            /// CPU wakeup with interrupt mask on event
            /// input
            IM6: u1,
            /// CPU wakeup with interrupt mask on event
            /// input
            IM7: u1,
            /// CPU wakeup with interrupt mask on event
            /// input
            IM8: u1,
            /// CPU wakeup with interrupt mask on event
            /// input
            IM9: u1,
            /// CPU wakeup with interrupt mask on event
            /// input
            IM10: u1,
            /// CPU wakeup with interrupt mask on event
            /// input
            IM11: u1,
            /// CPU wakeup with interrupt mask on event
            /// input
            IM12: u1,
            /// CPU wakeup with interrupt mask on event
            /// input
            IM13: u1,
            /// CPU wakeup with interrupt mask on event
            /// input
            IM14: u1,
            /// CPU wakeup with interrupt mask on event
            /// input
            IM15: u1,
            /// CPU wakeup with interrupt mask on event
            /// input
            IM16: u1,
            reserved0: u1,
            reserved1: u1,
            /// CPU wakeup with interrupt mask on event
            /// input
            IM19: u1,
            /// CPU wakeup with interrupt mask on event
            /// input
            IM20: u1,
            /// CPU wakeup with interrupt mask on event
            /// input
            IM21: u1,
            /// CPU wakeup with interrupt mask on event
            /// input
            IM22: u1,
            /// CPU wakeup with interrupt mask on event
            /// input
            IM23: u1,
            /// CPU wakeup with interrupt mask on event
            /// input
            IM24: u1,
            /// CPU wakeup with interrupt mask on event
            /// input
            IM25: u1,
            /// CPU wakeup with interrupt mask on event
            /// input
            IM26: u1,
            reserved2: u1,
            /// CPU wakeup with interrupt mask on event
            /// input
            IM28: u1,
            /// CPU wakeup with interrupt mask on event
            /// input
            IM29: u1,
            /// CPU wakeup with interrupt mask on event
            /// input
            IM30: u1,
            /// CPU wakeup with interrupt mask on event
            /// input
            IM31: u1,
        }), base_address + 0x80);

        /// address: 0x40021884
        /// EXTI CPU wakeup with event mask
        /// register
        pub const EMR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// CPU wakeup with event mask on event
            /// input
            EM0: u1,
            /// CPU wakeup with event mask on event
            /// input
            EM1: u1,
            /// CPU wakeup with event mask on event
            /// input
            EM2: u1,
            /// CPU wakeup with event mask on event
            /// input
            EM3: u1,
            /// CPU wakeup with event mask on event
            /// input
            EM4: u1,
            /// CPU wakeup with event mask on event
            /// input
            EM5: u1,
            /// CPU wakeup with event mask on event
            /// input
            EM6: u1,
            /// CPU wakeup with event mask on event
            /// input
            EM7: u1,
            /// CPU wakeup with event mask on event
            /// input
            EM8: u1,
            /// CPU wakeup with event mask on event
            /// input
            EM9: u1,
            /// CPU wakeup with event mask on event
            /// input
            EM10: u1,
            /// CPU wakeup with event mask on event
            /// input
            EM11: u1,
            /// CPU wakeup with event mask on event
            /// input
            EM12: u1,
            /// CPU wakeup with event mask on event
            /// input
            EM13: u1,
            /// CPU wakeup with event mask on event
            /// input
            EM14: u1,
            /// CPU wakeup with event mask on event
            /// input
            EM15: u1,
            /// CPU wakeup with event mask on event
            /// input
            EM16: u1,
            reserved0: u1,
            reserved1: u1,
            /// CPU wakeup with event mask on event
            /// input
            EM19: u1,
            reserved2: u1,
            /// CPU wakeup with event mask on event
            /// input
            EM21: u1,
            reserved3: u1,
            /// CPU wakeup with event mask on event
            /// input
            EM23: u1,
            reserved4: u1,
            /// CPU wakeup with event mask on event
            /// input
            EM25: u1,
            /// CPU wakeup with event mask on event
            /// input
            EM26: u1,
            reserved5: u1,
            /// CPU wakeup with event mask on event
            /// input
            EM28: u1,
            /// CPU wakeup with event mask on event
            /// input
            EM29: u1,
            /// CPU wakeup with event mask on event
            /// input
            EM30: u1,
            /// CPU wakeup with event mask on event
            /// input
            EM31: u1,
        }), base_address + 0x84);
    };

    /// General purpose timers
    pub const TIM16 = struct {
        pub const base_address = 0x40014400;

        /// address: 0x40014400
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            reserved3: u1,
            /// UIF status bit remapping
            UIFREMAP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x0);

        /// address: 0x40014404
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/compare preloaded
            /// control
            CCPC: u1,
            reserved0: u1,
            /// Capture/compare control update
            /// selection
            CCUS: u1,
            /// Capture/compare DMA
            /// selection
            CCDS: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Output Idle state 1
            OIS1: u1,
            /// Output Idle state 1
            OIS1N: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x4);

        /// address: 0x4001440c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// COM interrupt enable
            COMIE: u1,
            reserved3: u1,
            /// Break interrupt enable
            BIE: u1,
            /// Update DMA request enable
            UDE: u1,
            /// Capture/Compare 1 DMA request
            /// enable
            CC1DE: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// COM DMA request enable
            COMDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0xc);

        /// address: 0x40014410
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// COM interrupt flag
            COMIF: u1,
            reserved3: u1,
            /// Break interrupt flag
            BIF: u1,
            reserved4: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x10);

        /// address: 0x40014414
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/Compare control update
            /// generation
            COMG: u1,
            reserved3: u1,
            /// Break generation
            BG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x14);

        /// address: 0x40014418
        /// capture/compare mode register (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output Compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output Compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output Compare 1 mode
            OC1M: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Output Compare 1 mode
            OC1M_2: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x18);

        /// address: 0x40014418
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            IC1PSC: u2,
            /// Input capture 1 filter
            IC1F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x18);

        /// address: 0x40014420
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            /// Capture/Compare 1 complementary output
            /// enable
            CC1NE: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x20);

        /// address: 0x40014424
        /// counter
        pub const CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// counter value
            CNT: u16,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// UIF Copy
            UIFCPY: u1,
        }), base_address + 0x24);

        /// address: 0x40014428
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4001442c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);

        /// address: 0x40014430
        /// repetition counter register
        pub const RCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Repetition counter value
            REP: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x30);

        /// address: 0x40014434
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x34);

        /// address: 0x40014444
        /// break and dead-time register
        pub const BDTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dead-time generator setup
            DTG: u8,
            /// Lock configuration
            LOCK: u2,
            /// Off-state selection for Idle
            /// mode
            OSSI: u1,
            /// Off-state selection for Run
            /// mode
            OSSR: u1,
            /// Break enable
            BKE: u1,
            /// Break polarity
            BKP: u1,
            /// Automatic output enable
            AOE: u1,
            /// Main output enable
            MOE: u1,
            /// Break filter
            BKF: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Break Disarm
            BKDSRM: u1,
            reserved6: u1,
            /// Break Bidirectional
            BKBID: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x44);

        /// address: 0x40014448
        /// DMA control register
        pub const DCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA burst length
            DBL: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x48);

        /// address: 0x4001444c
        /// DMA address for full transfer
        pub const DMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA register for burst
            /// accesses
            DMAB: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);

        /// address: 0x40014460
        /// TIM17 option register 1
        pub const AF1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// BRK BKIN input enable
            BKINE: u1,
            /// BRK COMP1 enable
            BKCMP1E: u1,
            /// BRK COMP2 enable
            BKCMP2E: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// BRK DFSDM_BREAK1 enable
            BKDFBK1E: u1,
            /// BRK BKIN input polarity
            BKINP: u1,
            /// BRK COMP1 input polarity
            BKCMP1P: u1,
            /// BRK COMP2 input polarit
            BKCMP2P: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x60);

        /// address: 0x40014468
        /// input selection register
        pub const TISEL = @intToPtr(*volatile Mmio(32, packed struct {
            /// selects input
            TI1SEL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x68);
    };
    pub const TIM17 = struct {
        pub const base_address = 0x40014800;

        /// address: 0x40014800
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            reserved3: u1,
            /// UIF status bit remapping
            UIFREMAP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x0);

        /// address: 0x40014804
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/compare preloaded
            /// control
            CCPC: u1,
            reserved0: u1,
            /// Capture/compare control update
            /// selection
            CCUS: u1,
            /// Capture/compare DMA
            /// selection
            CCDS: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Output Idle state 1
            OIS1: u1,
            /// Output Idle state 1
            OIS1N: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x4);

        /// address: 0x4001480c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// COM interrupt enable
            COMIE: u1,
            reserved3: u1,
            /// Break interrupt enable
            BIE: u1,
            /// Update DMA request enable
            UDE: u1,
            /// Capture/Compare 1 DMA request
            /// enable
            CC1DE: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// COM DMA request enable
            COMDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0xc);

        /// address: 0x40014810
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// COM interrupt flag
            COMIF: u1,
            reserved3: u1,
            /// Break interrupt flag
            BIF: u1,
            reserved4: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x10);

        /// address: 0x40014814
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/Compare control update
            /// generation
            COMG: u1,
            reserved3: u1,
            /// Break generation
            BG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x14);

        /// address: 0x40014818
        /// capture/compare mode register (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output Compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output Compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output Compare 1 mode
            OC1M: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Output Compare 1 mode
            OC1M_2: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x18);

        /// address: 0x40014818
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            IC1PSC: u2,
            /// Input capture 1 filter
            IC1F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x18);

        /// address: 0x40014820
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            /// Capture/Compare 1 complementary output
            /// enable
            CC1NE: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x20);

        /// address: 0x40014824
        /// counter
        pub const CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// counter value
            CNT: u16,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// UIF Copy
            UIFCPY: u1,
        }), base_address + 0x24);

        /// address: 0x40014828
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4001482c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);

        /// address: 0x40014830
        /// repetition counter register
        pub const RCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Repetition counter value
            REP: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x30);

        /// address: 0x40014834
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x34);

        /// address: 0x40014844
        /// break and dead-time register
        pub const BDTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dead-time generator setup
            DTG: u8,
            /// Lock configuration
            LOCK: u2,
            /// Off-state selection for Idle
            /// mode
            OSSI: u1,
            /// Off-state selection for Run
            /// mode
            OSSR: u1,
            /// Break enable
            BKE: u1,
            /// Break polarity
            BKP: u1,
            /// Automatic output enable
            AOE: u1,
            /// Main output enable
            MOE: u1,
            /// Break filter
            BKF: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Break Disarm
            BKDSRM: u1,
            reserved6: u1,
            /// Break Bidirectional
            BKBID: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x44);

        /// address: 0x40014848
        /// DMA control register
        pub const DCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA burst length
            DBL: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x48);

        /// address: 0x4001484c
        /// DMA address for full transfer
        pub const DMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA register for burst
            /// accesses
            DMAB: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);

        /// address: 0x40014860
        /// TIM17 option register 1
        pub const AF1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// BRK BKIN input enable
            BKINE: u1,
            /// BRK COMP1 enable
            BKCMP1E: u1,
            /// BRK COMP2 enable
            BKCMP2E: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// BRK DFSDM_BREAK1 enable
            BKDFBK1E: u1,
            /// BRK BKIN input polarity
            BKINP: u1,
            /// BRK COMP1 input polarity
            BKCMP1P: u1,
            /// BRK COMP2 input polarit
            BKCMP2P: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x60);

        /// address: 0x40014868
        /// input selection register
        pub const TISEL = @intToPtr(*volatile Mmio(32, packed struct {
            /// selects input
            TI1SEL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x68);
    };

    /// Universal synchronous asynchronous receiver
    /// transmitter
    pub const USART1 = struct {
        pub const base_address = 0x40013800;

        /// address: 0x40013800
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// USART enable
            UE: u1,
            /// USART enable in Stop mode
            UESM: u1,
            /// Receiver enable
            RE: u1,
            /// Transmitter enable
            TE: u1,
            /// IDLE interrupt enable
            IDLEIE: u1,
            /// RXNE interrupt enable
            RXNEIE: u1,
            /// Transmission complete interrupt
            /// enable
            TCIE: u1,
            /// interrupt enable
            TXEIE: u1,
            /// PE interrupt enable
            PEIE: u1,
            /// Parity selection
            PS: u1,
            /// Parity control enable
            PCE: u1,
            /// Receiver wakeup method
            WAKE: u1,
            /// Word length
            M0: u1,
            /// Mute mode enable
            MME: u1,
            /// Character match interrupt
            /// enable
            CMIE: u1,
            /// Oversampling mode
            OVER8: u1,
            /// DEDT
            DEDT: u5,
            /// DEAT
            DEAT: u5,
            /// Receiver timeout interrupt
            /// enable
            RTOIE: u1,
            /// End of Block interrupt
            /// enable
            EOBIE: u1,
            /// Word length
            M1: u1,
            /// FIFO mode enable
            FIFOEN: u1,
            /// TXFIFO empty interrupt
            /// enable
            TXFEIE: u1,
            /// RXFIFO Full interrupt
            /// enable
            RXFFIE: u1,
        }), base_address + 0x0);

        /// address: 0x40013804
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Synchronous Slave mode
            /// enable
            SLVEN: u1,
            reserved0: u1,
            reserved1: u1,
            /// When the DSI_NSS bit is set, the NSS pin
            /// input will be ignored
            DIS_NSS: u1,
            /// 7-bit Address Detection/4-bit Address
            /// Detection
            ADDM7: u1,
            /// LIN break detection length
            LBDL: u1,
            /// LIN break detection interrupt
            /// enable
            LBDIE: u1,
            reserved2: u1,
            /// Last bit clock pulse
            LBCL: u1,
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Clock enable
            CLKEN: u1,
            /// STOP bits
            STOP: u2,
            /// LIN mode enable
            LINEN: u1,
            /// Swap TX/RX pins
            SWAP: u1,
            /// RX pin active level
            /// inversion
            RXINV: u1,
            /// TX pin active level
            /// inversion
            TXINV: u1,
            /// Binary data inversion
            TAINV: u1,
            /// Most significant bit first
            MSBFIRST: u1,
            /// Auto baud rate enable
            ABREN: u1,
            /// Auto baud rate mode
            ABRMOD: u2,
            /// Receiver timeout enable
            RTOEN: u1,
            /// Address of the USART node
            ADD0_3: u4,
            /// Address of the USART node
            ADD4_7: u4,
        }), base_address + 0x4);

        /// address: 0x40013808
        /// Control register 3
        pub const CR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Error interrupt enable
            EIE: u1,
            /// Ir mode enable
            IREN: u1,
            /// Ir low-power
            IRLP: u1,
            /// Half-duplex selection
            HDSEL: u1,
            /// Smartcard NACK enable
            NACK: u1,
            /// Smartcard mode enable
            SCEN: u1,
            /// DMA enable receiver
            DMAR: u1,
            /// DMA enable transmitter
            DMAT: u1,
            /// RTS enable
            RTSE: u1,
            /// CTS enable
            CTSE: u1,
            /// CTS interrupt enable
            CTSIE: u1,
            /// One sample bit method
            /// enable
            ONEBIT: u1,
            /// Overrun Disable
            OVRDIS: u1,
            /// DMA Disable on Reception
            /// Error
            DDRE: u1,
            /// Driver enable mode
            DEM: u1,
            /// Driver enable polarity
            /// selection
            DEP: u1,
            reserved0: u1,
            /// Smartcard auto-retry count
            SCARCNT: u3,
            /// Wakeup from Stop mode interrupt flag
            /// selection
            WUS: u2,
            /// Wakeup from Stop mode interrupt
            /// enable
            WUFIE: u1,
            /// threshold interrupt enable
            TXFTIE: u1,
            /// Tr Complete before guard time, interrupt
            /// enable
            TCBGTIE: u1,
            /// Receive FIFO threshold
            /// configuration
            RXFTCFG: u3,
            /// RXFIFO threshold interrupt
            /// enable
            RXFTIE: u1,
            /// TXFIFO threshold
            /// configuration
            TXFTCFG: u3,
        }), base_address + 0x8);

        /// address: 0x4001380c
        /// Baud rate register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// BRR_0_3
            BRR_0_3: u4,
            /// BRR_4_15
            BRR_4_15: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40013810
        /// Guard time and prescaler
        /// register
        pub const GTPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Prescaler value
            PSC: u8,
            /// Guard time value
            GT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40013814
        /// Receiver timeout register
        pub const RTOR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver timeout value
            RTO: u24,
            /// Block Length
            BLEN: u8,
        }), base_address + 0x14);

        /// address: 0x40013818
        /// Request register
        pub const RQR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Auto baud rate request
            ABRRQ: u1,
            /// Send break request
            SBKRQ: u1,
            /// Mute mode request
            MMRQ: u1,
            /// Receive data flush request
            RXFRQ: u1,
            /// Transmit data flush
            /// request
            TXFRQ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x18);

        /// address: 0x4001381c
        /// Interrupt & status
        /// register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PE
            PE: u1,
            /// FE
            FE: u1,
            /// NF
            NF: u1,
            /// ORE
            ORE: u1,
            /// IDLE
            IDLE: u1,
            /// RXNE
            RXNE: u1,
            /// TC
            TC: u1,
            /// TXE
            TXE: u1,
            /// LBDF
            LBDF: u1,
            /// CTSIF
            CTSIF: u1,
            /// CTS
            CTS: u1,
            /// RTOF
            RTOF: u1,
            /// EOBF
            EOBF: u1,
            /// SPI slave underrun error
            /// flag
            UDR: u1,
            /// ABRE
            ABRE: u1,
            /// ABRF
            ABRF: u1,
            /// BUSY
            BUSY: u1,
            /// CMF
            CMF: u1,
            /// SBKF
            SBKF: u1,
            /// RWU
            RWU: u1,
            /// WUF
            WUF: u1,
            /// TEACK
            TEACK: u1,
            /// REACK
            REACK: u1,
            /// TXFIFO Empty
            TXFE: u1,
            /// RXFIFO Full
            RXFF: u1,
            /// Transmission complete before guard time
            /// flag
            TCBGT: u1,
            /// RXFIFO threshold flag
            RXFT: u1,
            /// TXFIFO threshold flag
            TXFT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x1c);

        /// address: 0x40013820
        /// Interrupt flag clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error clear flag
            PECF: u1,
            /// Framing error clear flag
            FECF: u1,
            /// Noise detected clear flag
            NCF: u1,
            /// Overrun error clear flag
            ORECF: u1,
            /// Idle line detected clear
            /// flag
            IDLECF: u1,
            /// TXFIFO empty clear flag
            TXFECF: u1,
            /// Transmission complete clear
            /// flag
            TCCF: u1,
            /// Transmission complete before Guard time
            /// clear flag
            TCBGTCF: u1,
            /// LIN break detection clear
            /// flag
            LBDCF: u1,
            /// CTS clear flag
            CTSCF: u1,
            reserved0: u1,
            /// Receiver timeout clear
            /// flag
            RTOCF: u1,
            /// End of block clear flag
            EOBCF: u1,
            /// SPI slave underrun clear
            /// flag
            UDRCF: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Character match clear flag
            CMCF: u1,
            reserved4: u1,
            reserved5: u1,
            /// Wakeup from Stop mode clear
            /// flag
            WUCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x20);

        /// address: 0x40013824
        /// Receive data register
        pub const RDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x24);

        /// address: 0x40013828
        /// Transmit data register
        pub const TDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x28);

        /// address: 0x4001382c
        /// Prescaler register
        pub const PRESC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock prescaler
            PRESCALER: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x2c);
    };
    pub const USART2 = struct {
        pub const base_address = 0x40004400;

        /// address: 0x40004400
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// USART enable
            UE: u1,
            /// USART enable in Stop mode
            UESM: u1,
            /// Receiver enable
            RE: u1,
            /// Transmitter enable
            TE: u1,
            /// IDLE interrupt enable
            IDLEIE: u1,
            /// RXNE interrupt enable
            RXNEIE: u1,
            /// Transmission complete interrupt
            /// enable
            TCIE: u1,
            /// interrupt enable
            TXEIE: u1,
            /// PE interrupt enable
            PEIE: u1,
            /// Parity selection
            PS: u1,
            /// Parity control enable
            PCE: u1,
            /// Receiver wakeup method
            WAKE: u1,
            /// Word length
            M0: u1,
            /// Mute mode enable
            MME: u1,
            /// Character match interrupt
            /// enable
            CMIE: u1,
            /// Oversampling mode
            OVER8: u1,
            /// DEDT
            DEDT: u5,
            /// DEAT
            DEAT: u5,
            /// Receiver timeout interrupt
            /// enable
            RTOIE: u1,
            /// End of Block interrupt
            /// enable
            EOBIE: u1,
            /// Word length
            M1: u1,
            /// FIFO mode enable
            FIFOEN: u1,
            /// TXFIFO empty interrupt
            /// enable
            TXFEIE: u1,
            /// RXFIFO Full interrupt
            /// enable
            RXFFIE: u1,
        }), base_address + 0x0);

        /// address: 0x40004404
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Synchronous Slave mode
            /// enable
            SLVEN: u1,
            reserved0: u1,
            reserved1: u1,
            /// When the DSI_NSS bit is set, the NSS pin
            /// input will be ignored
            DIS_NSS: u1,
            /// 7-bit Address Detection/4-bit Address
            /// Detection
            ADDM7: u1,
            /// LIN break detection length
            LBDL: u1,
            /// LIN break detection interrupt
            /// enable
            LBDIE: u1,
            reserved2: u1,
            /// Last bit clock pulse
            LBCL: u1,
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Clock enable
            CLKEN: u1,
            /// STOP bits
            STOP: u2,
            /// LIN mode enable
            LINEN: u1,
            /// Swap TX/RX pins
            SWAP: u1,
            /// RX pin active level
            /// inversion
            RXINV: u1,
            /// TX pin active level
            /// inversion
            TXINV: u1,
            /// Binary data inversion
            TAINV: u1,
            /// Most significant bit first
            MSBFIRST: u1,
            /// Auto baud rate enable
            ABREN: u1,
            /// Auto baud rate mode
            ABRMOD: u2,
            /// Receiver timeout enable
            RTOEN: u1,
            /// Address of the USART node
            ADD0_3: u4,
            /// Address of the USART node
            ADD4_7: u4,
        }), base_address + 0x4);

        /// address: 0x40004408
        /// Control register 3
        pub const CR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Error interrupt enable
            EIE: u1,
            /// Ir mode enable
            IREN: u1,
            /// Ir low-power
            IRLP: u1,
            /// Half-duplex selection
            HDSEL: u1,
            /// Smartcard NACK enable
            NACK: u1,
            /// Smartcard mode enable
            SCEN: u1,
            /// DMA enable receiver
            DMAR: u1,
            /// DMA enable transmitter
            DMAT: u1,
            /// RTS enable
            RTSE: u1,
            /// CTS enable
            CTSE: u1,
            /// CTS interrupt enable
            CTSIE: u1,
            /// One sample bit method
            /// enable
            ONEBIT: u1,
            /// Overrun Disable
            OVRDIS: u1,
            /// DMA Disable on Reception
            /// Error
            DDRE: u1,
            /// Driver enable mode
            DEM: u1,
            /// Driver enable polarity
            /// selection
            DEP: u1,
            reserved0: u1,
            /// Smartcard auto-retry count
            SCARCNT: u3,
            /// Wakeup from Stop mode interrupt flag
            /// selection
            WUS: u2,
            /// Wakeup from Stop mode interrupt
            /// enable
            WUFIE: u1,
            /// threshold interrupt enable
            TXFTIE: u1,
            /// Tr Complete before guard time, interrupt
            /// enable
            TCBGTIE: u1,
            /// Receive FIFO threshold
            /// configuration
            RXFTCFG: u3,
            /// RXFIFO threshold interrupt
            /// enable
            RXFTIE: u1,
            /// TXFIFO threshold
            /// configuration
            TXFTCFG: u3,
        }), base_address + 0x8);

        /// address: 0x4000440c
        /// Baud rate register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// BRR_0_3
            BRR_0_3: u4,
            /// BRR_4_15
            BRR_4_15: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40004410
        /// Guard time and prescaler
        /// register
        pub const GTPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Prescaler value
            PSC: u8,
            /// Guard time value
            GT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40004414
        /// Receiver timeout register
        pub const RTOR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver timeout value
            RTO: u24,
            /// Block Length
            BLEN: u8,
        }), base_address + 0x14);

        /// address: 0x40004418
        /// Request register
        pub const RQR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Auto baud rate request
            ABRRQ: u1,
            /// Send break request
            SBKRQ: u1,
            /// Mute mode request
            MMRQ: u1,
            /// Receive data flush request
            RXFRQ: u1,
            /// Transmit data flush
            /// request
            TXFRQ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x18);

        /// address: 0x4000441c
        /// Interrupt & status
        /// register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PE
            PE: u1,
            /// FE
            FE: u1,
            /// NF
            NF: u1,
            /// ORE
            ORE: u1,
            /// IDLE
            IDLE: u1,
            /// RXNE
            RXNE: u1,
            /// TC
            TC: u1,
            /// TXE
            TXE: u1,
            /// LBDF
            LBDF: u1,
            /// CTSIF
            CTSIF: u1,
            /// CTS
            CTS: u1,
            /// RTOF
            RTOF: u1,
            /// EOBF
            EOBF: u1,
            /// SPI slave underrun error
            /// flag
            UDR: u1,
            /// ABRE
            ABRE: u1,
            /// ABRF
            ABRF: u1,
            /// BUSY
            BUSY: u1,
            /// CMF
            CMF: u1,
            /// SBKF
            SBKF: u1,
            /// RWU
            RWU: u1,
            /// WUF
            WUF: u1,
            /// TEACK
            TEACK: u1,
            /// REACK
            REACK: u1,
            /// TXFIFO Empty
            TXFE: u1,
            /// RXFIFO Full
            RXFF: u1,
            /// Transmission complete before guard time
            /// flag
            TCBGT: u1,
            /// RXFIFO threshold flag
            RXFT: u1,
            /// TXFIFO threshold flag
            TXFT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x1c);

        /// address: 0x40004420
        /// Interrupt flag clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error clear flag
            PECF: u1,
            /// Framing error clear flag
            FECF: u1,
            /// Noise detected clear flag
            NCF: u1,
            /// Overrun error clear flag
            ORECF: u1,
            /// Idle line detected clear
            /// flag
            IDLECF: u1,
            /// TXFIFO empty clear flag
            TXFECF: u1,
            /// Transmission complete clear
            /// flag
            TCCF: u1,
            /// Transmission complete before Guard time
            /// clear flag
            TCBGTCF: u1,
            /// LIN break detection clear
            /// flag
            LBDCF: u1,
            /// CTS clear flag
            CTSCF: u1,
            reserved0: u1,
            /// Receiver timeout clear
            /// flag
            RTOCF: u1,
            /// End of block clear flag
            EOBCF: u1,
            /// SPI slave underrun clear
            /// flag
            UDRCF: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Character match clear flag
            CMCF: u1,
            reserved4: u1,
            reserved5: u1,
            /// Wakeup from Stop mode clear
            /// flag
            WUCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x20);

        /// address: 0x40004424
        /// Receive data register
        pub const RDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x24);

        /// address: 0x40004428
        /// Transmit data register
        pub const TDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x28);

        /// address: 0x4000442c
        /// Prescaler register
        pub const PRESC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock prescaler
            PRESCALER: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x2c);
    };

    /// Serial peripheral interface/Inter-IC
    /// sound
    pub const SPI1 = struct {
        pub const base_address = 0x40013000;

        /// address: 0x40013000
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Master selection
            MSTR: u1,
            /// Baud rate control
            BR: u3,
            /// SPI enable
            SPE: u1,
            /// Frame format
            LSBFIRST: u1,
            /// Internal slave select
            SSI: u1,
            /// Software slave management
            SSM: u1,
            /// Receive only
            RXONLY: u1,
            /// Data frame format
            DFF: u1,
            /// CRC transfer next
            CRCNEXT: u1,
            /// Hardware CRC calculation
            /// enable
            CRCEN: u1,
            /// Output enable in bidirectional
            /// mode
            BIDIOE: u1,
            /// Bidirectional data mode
            /// enable
            BIDIMODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0x40013004
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx buffer DMA enable
            RXDMAEN: u1,
            /// Tx buffer DMA enable
            TXDMAEN: u1,
            /// SS output enable
            SSOE: u1,
            /// NSS pulse management
            NSSP: u1,
            /// Frame format
            FRF: u1,
            /// Error interrupt enable
            ERRIE: u1,
            /// RX buffer not empty interrupt
            /// enable
            RXNEIE: u1,
            /// Tx buffer empty interrupt
            /// enable
            TXEIE: u1,
            /// Data size
            DS: u4,
            /// FIFO reception threshold
            FRXTH: u1,
            /// Last DMA transfer for
            /// reception
            LDMA_RX: u1,
            /// Last DMA transfer for
            /// transmission
            LDMA_TX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x4);

        /// address: 0x40013008
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive buffer not empty
            RXNE: u1,
            /// Transmit buffer empty
            TXE: u1,
            /// Channel side
            CHSIDE: u1,
            /// Underrun flag
            UDR: u1,
            /// CRC error flag
            CRCERR: u1,
            /// Mode fault
            MODF: u1,
            /// Overrun flag
            OVR: u1,
            /// Busy flag
            BSY: u1,
            /// TI frame format error
            TIFRFE: u1,
            /// FIFO reception level
            FRLVL: u2,
            /// FIFO transmission level
            FTLVL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x8);

        /// address: 0x4001300c
        /// data register
        pub const DR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xc);

        /// address: 0x40013010
        /// CRC polynomial register
        pub const CRCPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// CRC polynomial register
            CRCPOLY: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40013014
        /// RX CRC register
        pub const RXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx CRC register
            RxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40013018
        /// TX CRC register
        pub const TXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tx CRC register
            TxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4001301c
        /// configuration register
        pub const I2SCFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel length (number of bits per audio
            /// channel)
            CHLEN: u1,
            /// Data length to be
            /// transferred
            DATLEN: u2,
            /// Inactive state clock
            /// polarity
            CKPOL: u1,
            /// standard selection
            I2SSTD: u2,
            reserved0: u1,
            /// PCM frame synchronization
            PCMSYNC: u1,
            /// I2S configuration mode
            I2SCFG: u2,
            /// I2S enable
            SE2: u1,
            /// I2S mode selection
            I2SMOD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x1c);

        /// address: 0x40013020
        /// prescaler register
        pub const I2SPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// linear prescaler
            I2SDIV: u8,
            /// Odd factor for the
            /// prescaler
            ODD: u1,
            /// Master clock output enable
            MCKOE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x20);
    };
    pub const SPI2 = struct {
        pub const base_address = 0x40003800;

        /// address: 0x40003800
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Master selection
            MSTR: u1,
            /// Baud rate control
            BR: u3,
            /// SPI enable
            SPE: u1,
            /// Frame format
            LSBFIRST: u1,
            /// Internal slave select
            SSI: u1,
            /// Software slave management
            SSM: u1,
            /// Receive only
            RXONLY: u1,
            /// Data frame format
            DFF: u1,
            /// CRC transfer next
            CRCNEXT: u1,
            /// Hardware CRC calculation
            /// enable
            CRCEN: u1,
            /// Output enable in bidirectional
            /// mode
            BIDIOE: u1,
            /// Bidirectional data mode
            /// enable
            BIDIMODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0x40003804
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx buffer DMA enable
            RXDMAEN: u1,
            /// Tx buffer DMA enable
            TXDMAEN: u1,
            /// SS output enable
            SSOE: u1,
            /// NSS pulse management
            NSSP: u1,
            /// Frame format
            FRF: u1,
            /// Error interrupt enable
            ERRIE: u1,
            /// RX buffer not empty interrupt
            /// enable
            RXNEIE: u1,
            /// Tx buffer empty interrupt
            /// enable
            TXEIE: u1,
            /// Data size
            DS: u4,
            /// FIFO reception threshold
            FRXTH: u1,
            /// Last DMA transfer for
            /// reception
            LDMA_RX: u1,
            /// Last DMA transfer for
            /// transmission
            LDMA_TX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x4);

        /// address: 0x40003808
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive buffer not empty
            RXNE: u1,
            /// Transmit buffer empty
            TXE: u1,
            /// Channel side
            CHSIDE: u1,
            /// Underrun flag
            UDR: u1,
            /// CRC error flag
            CRCERR: u1,
            /// Mode fault
            MODF: u1,
            /// Overrun flag
            OVR: u1,
            /// Busy flag
            BSY: u1,
            /// TI frame format error
            TIFRFE: u1,
            /// FIFO reception level
            FRLVL: u2,
            /// FIFO transmission level
            FTLVL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x8);

        /// address: 0x4000380c
        /// data register
        pub const DR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xc);

        /// address: 0x40003810
        /// CRC polynomial register
        pub const CRCPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// CRC polynomial register
            CRCPOLY: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40003814
        /// RX CRC register
        pub const RXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx CRC register
            RxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40003818
        /// TX CRC register
        pub const TXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tx CRC register
            TxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4000381c
        /// configuration register
        pub const I2SCFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel length (number of bits per audio
            /// channel)
            CHLEN: u1,
            /// Data length to be
            /// transferred
            DATLEN: u2,
            /// Inactive state clock
            /// polarity
            CKPOL: u1,
            /// standard selection
            I2SSTD: u2,
            reserved0: u1,
            /// PCM frame synchronization
            PCMSYNC: u1,
            /// I2S configuration mode
            I2SCFG: u2,
            /// I2S enable
            SE2: u1,
            /// I2S mode selection
            I2SMOD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x1c);

        /// address: 0x40003820
        /// prescaler register
        pub const I2SPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// linear prescaler
            I2SDIV: u8,
            /// Odd factor for the
            /// prescaler
            ODD: u1,
            /// Master clock output enable
            MCKOE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x20);
    };

    /// Advanced-timers
    pub const TIM1 = struct {
        pub const base_address = 0x40012c00;

        /// address: 0x40012c00
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            /// Direction
            DIR: u1,
            /// Center-aligned mode
            /// selection
            CMS: u2,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            reserved0: u1,
            /// UIF status bit remapping
            UIFREMAP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x0);

        /// address: 0x40012c04
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/compare preloaded
            /// control
            CCPC: u1,
            reserved0: u1,
            /// Capture/compare control update
            /// selection
            CCUS: u1,
            /// Capture/compare DMA
            /// selection
            CCDS: u1,
            /// Master mode selection
            MMS: u3,
            /// TI1 selection
            TI1S: u1,
            /// Output Idle state 1
            OIS1: u1,
            /// Output Idle state 1
            OIS1N: u1,
            /// Output Idle state 2
            OIS2: u1,
            /// Output Idle state 2
            OIS2N: u1,
            /// Output Idle state 3
            OIS3: u1,
            /// Output Idle state 3
            OIS3N: u1,
            /// Output Idle state 4
            OIS4: u1,
            reserved1: u1,
            /// Output Idle state 5 (OC5
            /// output)
            OIS5: u1,
            reserved2: u1,
            /// Output Idle state 6 (OC6
            /// output)
            OIS6: u1,
            reserved3: u1,
            /// Master mode selection 2
            MMS2: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x4);

        /// address: 0x40012c08
        /// slave mode control register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3,
            /// OCREF clear selection
            OCCS: u1,
            /// Trigger selection
            TS_4: u3,
            /// Master/Slave mode
            MSM: u1,
            /// External trigger filter
            ETF: u4,
            /// External trigger prescaler
            ETPS: u2,
            /// External clock enable
            ECE: u1,
            /// External trigger polarity
            ETP: u1,
            /// Slave mode selection - bit
            /// 3
            SMS_3: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Trigger selection
            TS: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x8);

        /// address: 0x40012c0c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            /// Capture/Compare 2 interrupt
            /// enable
            CC2IE: u1,
            /// Capture/Compare 3 interrupt
            /// enable
            CC3IE: u1,
            /// Capture/Compare 4 interrupt
            /// enable
            CC4IE: u1,
            /// COM interrupt enable
            COMIE: u1,
            /// Trigger interrupt enable
            TIE: u1,
            /// Break interrupt enable
            BIE: u1,
            /// Update DMA request enable
            UDE: u1,
            /// Capture/Compare 1 DMA request
            /// enable
            CC1DE: u1,
            /// Capture/Compare 2 DMA request
            /// enable
            CC2DE: u1,
            /// Capture/Compare 3 DMA request
            /// enable
            CC3DE: u1,
            /// Capture/Compare 4 DMA request
            /// enable
            CC4DE: u1,
            /// COM DMA request enable
            COMDE: u1,
            /// Trigger DMA request enable
            TDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40012c10
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            /// Capture/Compare 2 interrupt
            /// flag
            CC2IF: u1,
            /// Capture/Compare 3 interrupt
            /// flag
            CC3IF: u1,
            /// Capture/Compare 4 interrupt
            /// flag
            CC4IF: u1,
            /// COM interrupt flag
            COMIF: u1,
            /// Trigger interrupt flag
            TIF: u1,
            /// Break interrupt flag
            BIF: u1,
            /// Break 2 interrupt flag
            B2IF: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            /// Capture/compare 2 overcapture
            /// flag
            CC2OF: u1,
            /// Capture/Compare 3 overcapture
            /// flag
            CC3OF: u1,
            /// Capture/Compare 4 overcapture
            /// flag
            CC4OF: u1,
            /// System Break interrupt
            /// flag
            SBIF: u1,
            reserved0: u1,
            reserved1: u1,
            /// Compare 5 interrupt flag
            CC5IF: u1,
            /// Compare 6 interrupt flag
            CC6IF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x10);

        /// address: 0x40012c14
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            /// Capture/compare 2
            /// generation
            CC2G: u1,
            /// Capture/compare 3
            /// generation
            CC3G: u1,
            /// Capture/compare 4
            /// generation
            CC4G: u1,
            /// Capture/Compare control update
            /// generation
            COMG: u1,
            /// Trigger generation
            TG: u1,
            /// Break generation
            BG: u1,
            /// Break 2 generation
            B2G: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x14);

        /// address: 0x40012c18
        /// capture/compare mode register 1 (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output Compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output Compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output Compare 1 mode
            OC1M: u3,
            /// Output Compare 1 clear
            /// enable
            OC1CE: u1,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Output Compare 2 fast
            /// enable
            OC2FE: u1,
            /// Output Compare 2 preload
            /// enable
            OC2PE: u1,
            /// Output Compare 2 mode
            OC2M: u3,
            /// Output Compare 2 clear
            /// enable
            OC2CE: u1,
            /// Output Compare 1 mode - bit
            /// 3
            OC1M_3: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Output Compare 2 mode - bit
            /// 3
            OC2M_3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x18);

        /// address: 0x40012c18
        /// capture/compare mode register 1 (output
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output Compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output Compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output Compare 1 mode
            OC1M: u3,
            /// Output Compare 1 clear
            /// enable
            OC1CE: u1,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Output Compare 2 fast
            /// enable
            OC2FE: u1,
            /// Output Compare 2 preload
            /// enable
            OC2PE: u1,
            /// Output Compare 2 mode
            OC2M: u3,
            /// Output Compare 2 clear
            /// enable
            OC2CE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x40012c1c
        /// capture/compare mode register 2 (output
        /// mode)
        pub const CCMR2_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3
            /// selection
            CC3S: u2,
            /// Output compare 3 fast
            /// enable
            OC3FE: u1,
            /// Output compare 3 preload
            /// enable
            OC3PE: u1,
            /// Output compare 3 mode
            OC3M: u3,
            /// Output compare 3 clear
            /// enable
            OC3CE: u1,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Output compare 4 fast
            /// enable
            OC4FE: u1,
            /// Output compare 4 preload
            /// enable
            OC4PE: u1,
            /// Output compare 4 mode
            OC4M: u3,
            /// Output compare 4 clear
            /// enable
            OC4CE: u1,
            /// Output Compare 3 mode - bit
            /// 3
            OC3M_3: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Output Compare 4 mode - bit
            /// 3
            OC4M_3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1c);

        /// address: 0x40012c1c
        /// capture/compare mode register 2 (output
        /// mode)
        pub const CCMR2_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3
            /// selection
            CC3S: u2,
            /// Output compare 3 fast
            /// enable
            OC3FE: u1,
            /// Output compare 3 preload
            /// enable
            OC3PE: u1,
            /// Output compare 3 mode
            OC3M: u3,
            /// Output compare 3 clear
            /// enable
            OC3CE: u1,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Output compare 4 fast
            /// enable
            OC4FE: u1,
            /// Output compare 4 preload
            /// enable
            OC4PE: u1,
            /// Output compare 4 mode
            OC4M: u3,
            /// Output compare 4 clear
            /// enable
            OC4CE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40012c20
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            /// Capture/Compare 1 complementary output
            /// enable
            CC1NE: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            /// Capture/Compare 2 output
            /// enable
            CC2E: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2P: u1,
            /// Capture/Compare 2 complementary output
            /// enable
            CC2NE: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2NP: u1,
            /// Capture/Compare 3 output
            /// enable
            CC3E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3P: u1,
            /// Capture/Compare 3 complementary output
            /// enable
            CC3NE: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3NP: u1,
            /// Capture/Compare 4 output
            /// enable
            CC4E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC4P: u1,
            reserved0: u1,
            /// Capture/Compare 4 complementary output
            /// polarity
            CC4NP: u1,
            /// Capture/Compare 5 output
            /// enable
            CC5E: u1,
            /// Capture/Compare 5 output
            /// polarity
            CC5P: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/Compare 6 output
            /// enable
            CC6E: u1,
            /// Capture/Compare 6 output
            /// polarity
            CC6P: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x20);

        /// address: 0x40012c24
        /// counter
        pub const CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// counter value
            CNT: u16,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// UIF copy
            UIFCPY: u1,
        }), base_address + 0x24);

        /// address: 0x40012c28
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x40012c2c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);

        /// address: 0x40012c30
        /// repetition counter register
        pub const RCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Repetition counter value
            REP: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x30);

        /// address: 0x40012c34
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x34);

        /// address: 0x40012c38
        /// capture/compare register 2
        pub const CCR2 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x38);

        /// address: 0x40012c3c
        /// capture/compare register 3
        pub const CCR3 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x3c);

        /// address: 0x40012c40
        /// capture/compare register 4
        pub const CCR4 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x40);

        /// address: 0x40012c44
        /// break and dead-time register
        pub const BDTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dead-time generator setup
            DTG: u8,
            /// Lock configuration
            LOCK: u2,
            /// Off-state selection for Idle
            /// mode
            OSSI: u1,
            /// Off-state selection for Run
            /// mode
            OSSR: u1,
            /// Break enable
            BKE: u1,
            /// Break polarity
            BKP: u1,
            /// Automatic output enable
            AOE: u1,
            /// Main output enable
            MOE: u1,
            /// Break filter
            BKF: u4,
            /// Break 2 filter
            BK2F: u4,
            /// Break 2 enable
            BK2E: u1,
            /// Break 2 polarity
            BK2P: u1,
            /// Break Disarm
            BKDSRM: u1,
            /// Break2 Disarm
            BK2DSRM: u1,
            /// Break Bidirectional
            BKBID: u1,
            /// Break2 bidirectional
            BK2ID: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x44);

        /// address: 0x40012c48
        /// DMA control register
        pub const DCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA burst length
            DBL: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x48);

        /// address: 0x40012c4c
        /// DMA address for full transfer
        pub const DMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA register for burst
            /// accesses
            DMAB: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);

        /// address: 0x40012c50
        /// option register 1
        pub const OR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Ocref_clr source selection
            OCREF_CLR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x50);

        /// address: 0x40012c54
        /// capture/compare mode register 2 (output
        /// mode)
        pub const CCMR3_Output = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Output compare 5 fast
            /// enable
            OC5FE: u1,
            /// Output compare 5 preload
            /// enable
            OC5PE: u1,
            /// Output compare 5 mode
            OC5M: u3,
            /// Output compare 5 clear
            /// enable
            OC5CE: u1,
            reserved2: u1,
            reserved3: u1,
            /// Output compare 6 fast
            /// enable
            OC6FE: u1,
            /// Output compare 6 preload
            /// enable
            OC6PE: u1,
            /// Output compare 6 mode
            OC6M: u3,
            /// Output compare 6 clear
            /// enable
            OC6CE: u1,
            /// Output Compare 5 mode bit
            /// 3
            OC5M_bit3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// Output Compare 6 mode bit
            /// 3
            OC6M_bit3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x54);

        /// address: 0x40012c58
        /// capture/compare register 4
        pub const CCR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare value
            CCR5: u16,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// Group Channel 5 and Channel
            /// 1
            GC5C1: u1,
            /// Group Channel 5 and Channel
            /// 2
            GC5C2: u1,
            /// Group Channel 5 and Channel
            /// 3
            GC5C3: u1,
        }), base_address + 0x58);

        /// address: 0x40012c5c
        /// capture/compare register 4
        pub const CCR6 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x5c);

        /// address: 0x40012c60
        /// DMA address for full transfer
        pub const AF1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// BRK BKIN input enable
            BKINE: u1,
            /// BRK COMP1 enable
            BKCMP1E: u1,
            /// BRK COMP2 enable
            BKCMP2E: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// BRK BKIN input polarity
            BKINP: u1,
            /// BRK COMP1 input polarity
            BKCMP1P: u1,
            /// BRK COMP2 input polarity
            BKCMP2P: u1,
            reserved6: u1,
            reserved7: u1,
            /// ETR source selection
            ETRSEL: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x60);

        /// address: 0x40012c64
        /// DMA address for full transfer
        pub const AF2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// BRK2 BKIN input enable
            BK2INE: u1,
            /// BRK2 COMP1 enable
            BK2CMP1E: u1,
            /// BRK2 COMP2 enable
            BK2CMP2E: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// BRK2 DFSDM_BREAK0 enable
            BK2DFBK0E: u1,
            /// BRK2 BKIN input polarity
            BK2INP: u1,
            /// BRK2 COMP1 input polarity
            BK2CMP1P: u1,
            /// BRK2 COMP2 input polarity
            BK2CMP2P: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x64);

        /// address: 0x40012c68
        /// TIM1 timer input selection
        /// register
        pub const TISEL = @intToPtr(*volatile Mmio(32, packed struct {
            /// selects TI1[0] to TI1[15]
            /// input
            TI1SEL3_0: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// selects TI2[0] to TI2[15]
            /// input
            TI2SEL3_0: u4,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// selects TI3[0] to TI3[15]
            /// input
            TI3SEL3_0: u4,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// selects TI4[0] to TI4[15]
            /// input
            TI4SEL3_0: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x68);
    };

    /// Analog to Digital Converter instance
    /// 1
    pub const ADC = struct {
        pub const base_address = 0x40012400;

        /// address: 0x40012400
        /// ADC interrupt and status
        /// register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADC ready flag
            ADRDY: u1,
            /// ADC group regular end of sampling
            /// flag
            EOSMP: u1,
            /// ADC group regular end of unitary
            /// conversion flag
            EOC: u1,
            /// ADC group regular end of sequence
            /// conversions flag
            EOS: u1,
            /// ADC group regular overrun
            /// flag
            OVR: u1,
            reserved0: u1,
            reserved1: u1,
            /// ADC analog watchdog 1 flag
            AWD1: u1,
            /// ADC analog watchdog 2 flag
            AWD2: u1,
            /// ADC analog watchdog 3 flag
            AWD3: u1,
            reserved2: u1,
            /// End Of Calibration flag
            EOCAL: u1,
            reserved3: u1,
            /// Channel Configuration Ready
            /// flag
            CCRDY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x0);

        /// address: 0x40012404
        /// ADC interrupt enable register
        pub const IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADC ready interrupt
            ADRDYIE: u1,
            /// ADC group regular end of sampling
            /// interrupt
            EOSMPIE: u1,
            /// ADC group regular end of unitary
            /// conversion interrupt
            EOCIE: u1,
            /// ADC group regular end of sequence
            /// conversions interrupt
            EOSIE: u1,
            /// ADC group regular overrun
            /// interrupt
            OVRIE: u1,
            reserved0: u1,
            reserved1: u1,
            /// ADC analog watchdog 1
            /// interrupt
            AWD1IE: u1,
            /// ADC analog watchdog 2
            /// interrupt
            AWD2IE: u1,
            /// ADC analog watchdog 3
            /// interrupt
            AWD3IE: u1,
            reserved2: u1,
            /// End of calibration interrupt
            /// enable
            EOCALIE: u1,
            reserved3: u1,
            /// Channel Configuration Ready Interrupt
            /// enable
            CCRDYIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x4);

        /// address: 0x40012408
        /// ADC control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADC enable
            ADEN: u1,
            /// ADC disable
            ADDIS: u1,
            /// ADC group regular conversion
            /// start
            ADSTART: u1,
            reserved0: u1,
            /// ADC group regular conversion
            /// stop
            ADSTP: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            /// ADC voltage regulator
            /// enable
            ADVREGEN: u1,
            reserved24: u1,
            reserved25: u1,
            /// ADC calibration
            ADCAL: u1,
        }), base_address + 0x8);

        /// address: 0x4001240c
        /// ADC configuration register 1
        pub const CFGR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADC DMA transfer enable
            DMAEN: u1,
            /// ADC DMA transfer
            /// configuration
            DMACFG: u1,
            /// Scan sequence direction
            SCANDIR: u1,
            /// ADC data resolution
            RES: u2,
            /// ADC data alignement
            ALIGN: u1,
            /// ADC group regular external trigger
            /// source
            EXTSEL: u3,
            reserved0: u1,
            /// ADC group regular external trigger
            /// polarity
            EXTEN: u2,
            /// ADC group regular overrun
            /// configuration
            OVRMOD: u1,
            /// ADC group regular continuous conversion
            /// mode
            CONT: u1,
            /// Wait conversion mode
            WAIT: u1,
            /// Auto-off mode
            AUTOFF: u1,
            /// ADC group regular sequencer
            /// discontinuous mode
            DISCEN: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Mode selection of the ADC_CHSELR
            /// register
            CHSELRMOD: u1,
            /// ADC analog watchdog 1 monitoring a
            /// single channel or all channels
            AWD1SGL: u1,
            /// ADC analog watchdog 1 enable on scope
            /// ADC group regular
            AWD1EN: u1,
            reserved5: u1,
            reserved6: u1,
            /// ADC analog watchdog 1 monitored channel
            /// selection
            AWDCH1CH: u5,
            padding0: u1,
        }), base_address + 0xc);

        /// address: 0x40012410
        /// ADC configuration register 2
        pub const CFGR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADC oversampler enable on scope ADC
            /// group regular
            OVSE: u1,
            reserved0: u1,
            /// ADC oversampling ratio
            OVSR: u3,
            /// ADC oversampling shift
            OVSS: u4,
            /// ADC oversampling discontinuous mode
            /// (triggered mode) for ADC group regular
            TOVS: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            /// Low frequency trigger mode
            /// enable
            LFTRIG: u1,
            /// ADC clock mode
            CKMODE: u2,
        }), base_address + 0x10);

        /// address: 0x40012414
        /// ADC sampling time register
        pub const SMPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sampling time selection
            SMP1: u3,
            reserved0: u1,
            /// Sampling time selection
            SMP2: u3,
            reserved1: u1,
            /// Channel sampling time
            /// selection
            SMPSEL: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x14);

        /// address: 0x40012420
        /// watchdog threshold register
        pub const AWD1TR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADC analog watchdog 1 threshold
            /// low
            LT1: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// ADC analog watchdog 1 threshold
            /// high
            HT1: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x20);

        /// address: 0x40012424
        /// watchdog threshold register
        pub const AWD2TR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADC analog watchdog 2 threshold
            /// low
            LT2: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// ADC analog watchdog 2 threshold
            /// high
            HT2: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x24);

        /// address: 0x40012428
        /// channel selection register
        pub const CHSELR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel-x selection
            CHSEL: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x28);

        /// address: 0x40012428
        /// channel selection register CHSELRMOD = 1 in
        /// ADC_CFGR1
        pub const CHSELR_1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// conversion of the sequence
            SQ1: u4,
            /// conversion of the sequence
            SQ2: u4,
            /// conversion of the sequence
            SQ3: u4,
            /// conversion of the sequence
            SQ4: u4,
            /// conversion of the sequence
            SQ5: u4,
            /// conversion of the sequence
            SQ6: u4,
            /// conversion of the sequence
            SQ7: u4,
            /// conversion of the sequence
            SQ8: u4,
        }), base_address + 0x28);

        /// address: 0x4001242c
        /// watchdog threshold register
        pub const AWD3TR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADC analog watchdog 3 threshold
            /// high
            LT3: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// ADC analog watchdog 3 threshold
            /// high
            HT3: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x2c);

        /// address: 0x40012440
        /// ADC group regular conversion data
        /// register
        pub const DR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADC group regular conversion
            /// data
            regularDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x40);

        /// address: 0x400124a0
        /// ADC analog watchdog 2 configuration
        /// register
        pub const AWD2CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADC analog watchdog 2 monitored channel
            /// selection
            AWD2CH: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xa0);

        /// address: 0x400124a4
        /// ADC analog watchdog 3 configuration
        /// register
        pub const AWD3CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADC analog watchdog 3 monitored channel
            /// selection
            AWD3CH: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xa4);

        /// address: 0x400124b4
        /// ADC calibration factors
        /// register
        pub const CALFACT = @intToPtr(*volatile MmioInt(32, u7), base_address + 0xb4);

        /// address: 0x40012708
        /// ADC common control register
        pub const CCR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            /// ADC prescaler
            PRESC: u4,
            /// VREFINT enable
            VREFEN: u1,
            /// Temperature sensor enable
            TSEN: u1,
            /// VBAT enable
            VBATEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x308);
    };

    /// System configuration controller
    pub const SYSCFG = struct {
        pub const base_address = 0x40010000;

        /// address: 0x40010000
        /// SYSCFG configuration register
        /// 1
        pub const CFGR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory mapping selection
            /// bits
            MEM_MODE: u2,
            reserved0: u1,
            reserved1: u1,
            /// PA11 and PA12 remapping
            /// bit.
            PA11_PA12_RMP: u1,
            /// IR output polarity
            /// selection
            IR_POL: u1,
            /// IR Modulation Envelope signal
            /// selection.
            IR_MOD: u2,
            /// I/O analog switch voltage booster
            /// enable
            BOOSTEN: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Fast Mode Plus (FM+) driving capability
            /// activation bits
            I2C_PBx_FMP: u4,
            /// FM+ driving capability activation for
            /// I2C1
            I2C1_FMP: u1,
            /// FM+ driving capability activation for
            /// I2C2
            I2C2_FMP: u1,
            /// Fast Mode Plus (FM+) driving capability
            /// activation bits
            I2C_PAx_FMP: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x0);

        /// address: 0x40010018
        /// SYSCFG configuration register
        /// 1
        pub const CFGR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Cortex-M0+ LOCKUP bit enable
            /// bit
            LOCKUP_LOCK: u1,
            /// SRAM parity lock bit
            SRAM_PARITY_LOCK: u1,
            /// PVD lock enable bit
            PVD_LOCK: u1,
            /// ECC error lock bit
            ECC_LOCK: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// SRAM parity error flag
            SRAM_PEF: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// PA1_CDEN
            PA1_CDEN: u1,
            /// PA3_CDEN
            PA3_CDEN: u1,
            /// PA5_CDEN
            PA5_CDEN: u1,
            /// PA6_CDEN
            PA6_CDEN: u1,
            /// PA13_CDEN
            PA13_CDEN: u1,
            /// PB0_CDEN
            PB0_CDEN: u1,
            /// PB1_CDEN
            PB1_CDEN: u1,
            /// PB2_CDEN
            PB2_CDEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x18);
    };

    /// Tamper and backup registers
    pub const TAMP = struct {
        pub const base_address = 0x4000b000;

        /// address: 0x4000b000
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TAMP1E
            TAMP1E: u1,
            /// TAMP2E
            TAMP2E: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// ITAMP1E
            ITAMP1E: u1,
            reserved14: u1,
            /// ITAMP3E
            ITAMP3E: u1,
            /// ITAMP4E
            ITAMP4E: u1,
            /// ITAMP5E
            ITAMP5E: u1,
            /// ITAMP6E
            ITAMP6E: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x0);

        /// address: 0x4000b004
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TAMP1NOER
            TAMP1NOER: u1,
            /// TAMP2NOER
            TAMP2NOER: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// TAMP1MSK
            TAMP1MSK: u1,
            /// TAMP2MSK
            TAMP2MSK: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            /// TAMP1TRG
            TAMP1TRG: u1,
            /// TAMP2TRG
            TAMP2TRG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x4);

        /// address: 0x4000b00c
        /// TAMP filter control register
        pub const FLTCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// TAMPFREQ
            TAMPFREQ: u3,
            /// TAMPFLT
            TAMPFLT: u2,
            /// TAMPPRCH
            TAMPPRCH: u2,
            /// TAMPPUDIS
            TAMPPUDIS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0xc);

        /// address: 0x4000b02c
        /// TAMP interrupt enable register
        pub const IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// TAMP1IE
            TAMP1IE: u1,
            /// TAMP2IE
            TAMP2IE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// ITAMP1IE
            ITAMP1IE: u1,
            reserved14: u1,
            /// ITAMP3IE
            ITAMP3IE: u1,
            /// ITAMP4IE
            ITAMP4IE: u1,
            /// ITAMP5IE
            ITAMP5IE: u1,
            /// ITAMP6IE
            ITAMP6IE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x2c);

        /// address: 0x4000b030
        /// TAMP status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// TAMP1F
            TAMP1F: u1,
            /// TAMP2F
            TAMP2F: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// ITAMP1F
            ITAMP1F: u1,
            reserved14: u1,
            /// ITAMP3F
            ITAMP3F: u1,
            /// ITAMP4F
            ITAMP4F: u1,
            /// ITAMP5F
            ITAMP5F: u1,
            /// ITAMP6F
            ITAMP6F: u1,
            /// ITAMP7F
            ITAMP7F: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x30);

        /// address: 0x4000b034
        /// TAMP masked interrupt status
        /// register
        pub const MISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// TAMP1MF:
            TAMP1MF: u1,
            /// TAMP2MF
            TAMP2MF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// ITAMP1MF
            ITAMP1MF: u1,
            reserved14: u1,
            /// ITAMP3MF
            ITAMP3MF: u1,
            /// ITAMP4MF
            ITAMP4MF: u1,
            /// ITAMP5MF
            ITAMP5MF: u1,
            /// ITAMP6MF
            ITAMP6MF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x34);

        /// address: 0x4000b03c
        /// TAMP status clear register
        pub const SCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// CTAMP1F
            CTAMP1F: u1,
            /// CTAMP2F
            CTAMP2F: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// CITAMP1F
            CITAMP1F: u1,
            reserved14: u1,
            /// CITAMP3F
            CITAMP3F: u1,
            /// CITAMP4F
            CITAMP4F: u1,
            /// CITAMP5F
            CITAMP5F: u1,
            /// CITAMP6F
            CITAMP6F: u1,
            /// CITAMP7F
            CITAMP7F: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x3c);

        /// address: 0x4000b100
        /// TAMP backup register
        pub const BKP0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x100);

        /// address: 0x4000b104
        /// TAMP backup register
        pub const BKP1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x104);

        /// address: 0x4000b108
        /// TAMP backup register
        pub const BKP2R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x108);

        /// address: 0x4000b10c
        /// TAMP backup register
        pub const BKP3R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x10c);

        /// address: 0x4000b110
        /// TAMP backup register
        pub const BKP4R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x110);
    };

    /// Inter-integrated circuit
    pub const I2C1 = struct {
        pub const base_address = 0x40005400;

        /// address: 0x40005400
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral enable
            PE: u1,
            /// TX Interrupt enable
            TXIE: u1,
            /// RX Interrupt enable
            RXIE: u1,
            /// Address match interrupt enable (slave
            /// only)
            ADDRIE: u1,
            /// Not acknowledge received interrupt
            /// enable
            NACKIE: u1,
            /// STOP detection Interrupt
            /// enable
            STOPIE: u1,
            /// Transfer Complete interrupt
            /// enable
            TCIE: u1,
            /// Error interrupts enable
            ERRIE: u1,
            /// Digital noise filter
            DNF: u4,
            /// Analog noise filter OFF
            ANFOFF: u1,
            reserved0: u1,
            /// DMA transmission requests
            /// enable
            TXDMAEN: u1,
            /// DMA reception requests
            /// enable
            RXDMAEN: u1,
            /// Slave byte control
            SBC: u1,
            /// Clock stretching disable
            NOSTRETCH: u1,
            /// Wakeup from STOP enable
            WUPEN: u1,
            /// General call enable
            GCEN: u1,
            /// SMBus Host address enable
            SMBHEN: u1,
            /// SMBus Device Default address
            /// enable
            SMBDEN: u1,
            /// SMBUS alert enable
            ALERTEN: u1,
            /// PEC enable
            PECEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x0);

        /// address: 0x40005404
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave address bit (master
            /// mode)
            SADD: u10,
            /// Transfer direction (master
            /// mode)
            RD_WRN: u1,
            /// 10-bit addressing mode (master
            /// mode)
            ADD10: u1,
            /// 10-bit address header only read
            /// direction (master receiver mode)
            HEAD10R: u1,
            /// Start generation
            START: u1,
            /// Stop generation (master
            /// mode)
            STOP: u1,
            /// NACK generation (slave
            /// mode)
            NACK: u1,
            /// Number of bytes
            NBYTES: u8,
            /// NBYTES reload mode
            RELOAD: u1,
            /// Automatic end mode (master
            /// mode)
            AUTOEND: u1,
            /// Packet error checking byte
            PECBYTE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x4);

        /// address: 0x40005408
        /// Own address register 1
        pub const OAR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interface address
            OA1_0: u1,
            /// Interface address
            OA1_7_1: u7,
            /// Interface address
            OA1_8_9: u2,
            /// Own Address 1 10-bit mode
            OA1MODE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Own Address 1 enable
            OA1EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4000540c
        /// Own address register 2
        pub const OAR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Interface address
            OA2: u7,
            /// Own Address 2 masks
            OA2MSK: u3,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Own Address 2 enable
            OA2EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40005410
        /// Timing register
        pub const TIMINGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SCL low period (master
            /// mode)
            SCLL: u8,
            /// SCL high period (master
            /// mode)
            SCLH: u8,
            /// Data hold time
            SDADEL: u4,
            /// Data setup time
            SCLDEL: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Timing prescaler
            PRESC: u4,
        }), base_address + 0x10);

        /// address: 0x40005414
        /// Status register 1
        pub const TIMEOUTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bus timeout A
            TIMEOUTA: u12,
            /// Idle clock timeout
            /// detection
            TIDLE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Clock timeout enable
            TIMOUTEN: u1,
            /// Bus timeout B
            TIMEOUTB: u12,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Extended clock timeout
            /// enable
            TEXTEN: u1,
        }), base_address + 0x14);

        /// address: 0x40005418
        /// Interrupt and Status register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit data register empty
            /// (transmitters)
            TXE: u1,
            /// Transmit interrupt status
            /// (transmitters)
            TXIS: u1,
            /// Receive data register not empty
            /// (receivers)
            RXNE: u1,
            /// Address matched (slave
            /// mode)
            ADDR: u1,
            /// Not acknowledge received
            /// flag
            NACKF: u1,
            /// Stop detection flag
            STOPF: u1,
            /// Transfer Complete (master
            /// mode)
            TC: u1,
            /// Transfer Complete Reload
            TCR: u1,
            /// Bus error
            BERR: u1,
            /// Arbitration lost
            ARLO: u1,
            /// Overrun/Underrun (slave
            /// mode)
            OVR: u1,
            /// PEC Error in reception
            PECERR: u1,
            /// Timeout or t_low detection
            /// flag
            TIMEOUT: u1,
            /// SMBus alert
            ALERT: u1,
            reserved0: u1,
            /// Bus busy
            BUSY: u1,
            /// Transfer direction (Slave
            /// mode)
            DIR: u1,
            /// Address match code (Slave
            /// mode)
            ADDCODE: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x18);

        /// address: 0x4000541c
        /// Interrupt clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Address Matched flag clear
            ADDRCF: u1,
            /// Not Acknowledge flag clear
            NACKCF: u1,
            /// Stop detection flag clear
            STOPCF: u1,
            reserved3: u1,
            reserved4: u1,
            /// Bus error flag clear
            BERRCF: u1,
            /// Arbitration lost flag
            /// clear
            ARLOCF: u1,
            /// Overrun/Underrun flag
            /// clear
            OVRCF: u1,
            /// PEC Error flag clear
            PECCF: u1,
            /// Timeout detection flag
            /// clear
            TIMOUTCF: u1,
            /// Alert flag clear
            ALERTCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x1c);

        /// address: 0x40005420
        /// PEC register
        pub const PECR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Packet error checking
            /// register
            PEC: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x20);

        /// address: 0x40005424
        /// Receive data register
        pub const RXDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 8-bit receive data
            RXDATA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x24);

        /// address: 0x40005428
        /// Transmit data register
        pub const TXDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 8-bit transmit data
            TXDATA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x28);
    };
    pub const I2C2 = struct {
        pub const base_address = 0x40005800;

        /// address: 0x40005800
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral enable
            PE: u1,
            /// TX Interrupt enable
            TXIE: u1,
            /// RX Interrupt enable
            RXIE: u1,
            /// Address match interrupt enable (slave
            /// only)
            ADDRIE: u1,
            /// Not acknowledge received interrupt
            /// enable
            NACKIE: u1,
            /// STOP detection Interrupt
            /// enable
            STOPIE: u1,
            /// Transfer Complete interrupt
            /// enable
            TCIE: u1,
            /// Error interrupts enable
            ERRIE: u1,
            /// Digital noise filter
            DNF: u4,
            /// Analog noise filter OFF
            ANFOFF: u1,
            reserved0: u1,
            /// DMA transmission requests
            /// enable
            TXDMAEN: u1,
            /// DMA reception requests
            /// enable
            RXDMAEN: u1,
            /// Slave byte control
            SBC: u1,
            /// Clock stretching disable
            NOSTRETCH: u1,
            /// Wakeup from STOP enable
            WUPEN: u1,
            /// General call enable
            GCEN: u1,
            /// SMBus Host address enable
            SMBHEN: u1,
            /// SMBus Device Default address
            /// enable
            SMBDEN: u1,
            /// SMBUS alert enable
            ALERTEN: u1,
            /// PEC enable
            PECEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x0);

        /// address: 0x40005804
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave address bit (master
            /// mode)
            SADD: u10,
            /// Transfer direction (master
            /// mode)
            RD_WRN: u1,
            /// 10-bit addressing mode (master
            /// mode)
            ADD10: u1,
            /// 10-bit address header only read
            /// direction (master receiver mode)
            HEAD10R: u1,
            /// Start generation
            START: u1,
            /// Stop generation (master
            /// mode)
            STOP: u1,
            /// NACK generation (slave
            /// mode)
            NACK: u1,
            /// Number of bytes
            NBYTES: u8,
            /// NBYTES reload mode
            RELOAD: u1,
            /// Automatic end mode (master
            /// mode)
            AUTOEND: u1,
            /// Packet error checking byte
            PECBYTE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x4);

        /// address: 0x40005808
        /// Own address register 1
        pub const OAR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interface address
            OA1_0: u1,
            /// Interface address
            OA1_7_1: u7,
            /// Interface address
            OA1_8_9: u2,
            /// Own Address 1 10-bit mode
            OA1MODE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Own Address 1 enable
            OA1EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4000580c
        /// Own address register 2
        pub const OAR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Interface address
            OA2: u7,
            /// Own Address 2 masks
            OA2MSK: u3,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Own Address 2 enable
            OA2EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40005810
        /// Timing register
        pub const TIMINGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SCL low period (master
            /// mode)
            SCLL: u8,
            /// SCL high period (master
            /// mode)
            SCLH: u8,
            /// Data hold time
            SDADEL: u4,
            /// Data setup time
            SCLDEL: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Timing prescaler
            PRESC: u4,
        }), base_address + 0x10);

        /// address: 0x40005814
        /// Status register 1
        pub const TIMEOUTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bus timeout A
            TIMEOUTA: u12,
            /// Idle clock timeout
            /// detection
            TIDLE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Clock timeout enable
            TIMOUTEN: u1,
            /// Bus timeout B
            TIMEOUTB: u12,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Extended clock timeout
            /// enable
            TEXTEN: u1,
        }), base_address + 0x14);

        /// address: 0x40005818
        /// Interrupt and Status register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit data register empty
            /// (transmitters)
            TXE: u1,
            /// Transmit interrupt status
            /// (transmitters)
            TXIS: u1,
            /// Receive data register not empty
            /// (receivers)
            RXNE: u1,
            /// Address matched (slave
            /// mode)
            ADDR: u1,
            /// Not acknowledge received
            /// flag
            NACKF: u1,
            /// Stop detection flag
            STOPF: u1,
            /// Transfer Complete (master
            /// mode)
            TC: u1,
            /// Transfer Complete Reload
            TCR: u1,
            /// Bus error
            BERR: u1,
            /// Arbitration lost
            ARLO: u1,
            /// Overrun/Underrun (slave
            /// mode)
            OVR: u1,
            /// PEC Error in reception
            PECERR: u1,
            /// Timeout or t_low detection
            /// flag
            TIMEOUT: u1,
            /// SMBus alert
            ALERT: u1,
            reserved0: u1,
            /// Bus busy
            BUSY: u1,
            /// Transfer direction (Slave
            /// mode)
            DIR: u1,
            /// Address match code (Slave
            /// mode)
            ADDCODE: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x18);

        /// address: 0x4000581c
        /// Interrupt clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Address Matched flag clear
            ADDRCF: u1,
            /// Not Acknowledge flag clear
            NACKCF: u1,
            /// Stop detection flag clear
            STOPCF: u1,
            reserved3: u1,
            reserved4: u1,
            /// Bus error flag clear
            BERRCF: u1,
            /// Arbitration lost flag
            /// clear
            ARLOCF: u1,
            /// Overrun/Underrun flag
            /// clear
            OVRCF: u1,
            /// PEC Error flag clear
            PECCF: u1,
            /// Timeout detection flag
            /// clear
            TIMOUTCF: u1,
            /// Alert flag clear
            ALERTCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x1c);

        /// address: 0x40005820
        /// PEC register
        pub const PECR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Packet error checking
            /// register
            PEC: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x20);

        /// address: 0x40005824
        /// Receive data register
        pub const RXDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 8-bit receive data
            RXDATA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x24);

        /// address: 0x40005828
        /// Transmit data register
        pub const TXDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 8-bit transmit data
            TXDATA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x28);
    };

    /// Real-time clock
    pub const RTC = struct {
        pub const base_address = 0x40002800;

        /// address: 0x40002800
        /// time register
        pub const TR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Second units in BCD format
            SU: u4,
            /// Second tens in BCD format
            ST: u3,
            reserved0: u1,
            /// Minute units in BCD format
            MNU: u4,
            /// Minute tens in BCD format
            MNT: u3,
            reserved1: u1,
            /// Hour units in BCD format
            HU: u4,
            /// Hour tens in BCD format
            HT: u2,
            /// AM/PM notation
            PM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x0);

        /// address: 0x40002804
        /// date register
        pub const DR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Date units in BCD format
            DU: u4,
            /// Date tens in BCD format
            DT: u2,
            reserved0: u1,
            reserved1: u1,
            /// Month units in BCD format
            MU: u4,
            /// Month tens in BCD format
            MT: u1,
            /// Week day units
            WDU: u3,
            /// Year units in BCD format
            YU: u4,
            /// Year tens in BCD format
            YT: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x4);

        /// address: 0x40002808
        /// sub second register
        pub const SSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sub second value
            SS: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4000280c
        /// initialization and status
        /// register
        pub const ICSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alarm A write flag
            ALRAWF: u1,
            /// Alarm B write flag
            ALRBWF: u1,
            /// Wakeup timer write flag
            WUTWF: u1,
            /// Shift operation pending
            SHPF: u1,
            /// Initialization status flag
            INITS: u1,
            /// Registers synchronization
            /// flag
            RSF: u1,
            /// Initialization flag
            INITF: u1,
            /// Initialization mode
            INIT: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Recalibration pending Flag
            RECALPF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0xc);

        /// address: 0x40002810
        /// prescaler register
        pub const PRER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Synchronous prescaler
            /// factor
            PREDIV_S: u15,
            reserved0: u1,
            /// Asynchronous prescaler
            /// factor
            PREDIV_A: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x10);

        /// address: 0x40002814
        /// wakeup timer register
        pub const WUTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Wakeup auto-reload value
            /// bits
            WUT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40002818
        /// control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// WUCKSEL
            WUCKSEL: u3,
            /// TSEDGE
            TSEDGE: u1,
            /// REFCKON
            REFCKON: u1,
            /// BYPSHAD
            BYPSHAD: u1,
            /// FMT
            FMT: u1,
            reserved0: u1,
            /// ALRAE
            ALRAE: u1,
            /// ALRBE
            ALRBE: u1,
            /// WUTE
            WUTE: u1,
            /// TSE
            TSE: u1,
            /// ALRAIE
            ALRAIE: u1,
            /// ALRBIE
            ALRBIE: u1,
            /// WUTIE
            WUTIE: u1,
            /// TSIE
            TSIE: u1,
            /// ADD1H
            ADD1H: u1,
            /// SUB1H
            SUB1H: u1,
            /// BKP
            BKP: u1,
            /// COSEL
            COSEL: u1,
            /// POL
            POL: u1,
            /// OSEL
            OSEL: u2,
            /// COE
            COE: u1,
            /// ITSE
            ITSE: u1,
            /// TAMPTS
            TAMPTS: u1,
            /// TAMPOE
            TAMPOE: u1,
            reserved1: u1,
            reserved2: u1,
            /// TAMPALRM_PU
            TAMPALRM_PU: u1,
            /// TAMPALRM_TYPE
            TAMPALRM_TYPE: u1,
            /// OUT2EN
            OUT2EN: u1,
        }), base_address + 0x18);

        /// address: 0x40002824
        /// write protection register
        pub const WPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write protection key
            KEY: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x24);

        /// address: 0x40002828
        /// calibration register
        pub const CALR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Calibration minus
            CALM: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Use a 16-second calibration cycle
            /// period
            CALW16: u1,
            /// Use an 8-second calibration cycle
            /// period
            CALW8: u1,
            /// Increase frequency of RTC by 488.5
            /// ppm
            CALP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);

        /// address: 0x4000282c
        /// shift control register
        pub const SHIFTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Subtract a fraction of a
            /// second
            SUBFS: u15,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Add one second
            ADD1S: u1,
        }), base_address + 0x2c);

        /// address: 0x40002830
        /// time stamp time register
        pub const TSTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Second units in BCD format
            SU: u4,
            /// Second tens in BCD format
            ST: u3,
            reserved0: u1,
            /// Minute units in BCD format
            MNU: u4,
            /// Minute tens in BCD format
            MNT: u3,
            reserved1: u1,
            /// Hour units in BCD format
            HU: u4,
            /// Hour tens in BCD format
            HT: u2,
            /// AM/PM notation
            PM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x30);

        /// address: 0x40002834
        /// time stamp date register
        pub const TSDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Date units in BCD format
            DU: u4,
            /// Date tens in BCD format
            DT: u2,
            reserved0: u1,
            reserved1: u1,
            /// Month units in BCD format
            MU: u4,
            /// Month tens in BCD format
            MT: u1,
            /// Week day units
            WDU: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x34);

        /// address: 0x40002838
        /// timestamp sub second register
        pub const TSSSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sub second value
            SS: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x38);

        /// address: 0x40002840
        /// alarm A register
        pub const ALRMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Second units in BCD format
            SU: u4,
            /// Second tens in BCD format
            ST: u3,
            /// Alarm A seconds mask
            MSK1: u1,
            /// Minute units in BCD format
            MNU: u4,
            /// Minute tens in BCD format
            MNT: u3,
            /// Alarm A minutes mask
            MSK2: u1,
            /// Hour units in BCD format
            HU: u4,
            /// Hour tens in BCD format
            HT: u2,
            /// AM/PM notation
            PM: u1,
            /// Alarm A hours mask
            MSK3: u1,
            /// Date units or day in BCD
            /// format
            DU: u4,
            /// Date tens in BCD format
            DT: u2,
            /// Week day selection
            WDSEL: u1,
            /// Alarm A date mask
            MSK4: u1,
        }), base_address + 0x40);

        /// address: 0x40002844
        /// alarm A sub second register
        pub const ALRMASSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sub seconds value
            SS: u15,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Mask the most-significant bits starting
            /// at this bit
            MASKSS: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x44);

        /// address: 0x40002848
        /// alarm B register
        pub const ALRMBR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Second units in BCD format
            SU: u4,
            /// Second tens in BCD format
            ST: u3,
            /// Alarm B seconds mask
            MSK1: u1,
            /// Minute units in BCD format
            MNU: u4,
            /// Minute tens in BCD format
            MNT: u3,
            /// Alarm B minutes mask
            MSK2: u1,
            /// Hour units in BCD format
            HU: u4,
            /// Hour tens in BCD format
            HT: u2,
            /// AM/PM notation
            PM: u1,
            /// Alarm B hours mask
            MSK3: u1,
            /// Date units or day in BCD
            /// format
            DU: u4,
            /// Date tens in BCD format
            DT: u2,
            /// Week day selection
            WDSEL: u1,
            /// Alarm B date mask
            MSK4: u1,
        }), base_address + 0x48);

        /// address: 0x4000284c
        /// alarm B sub second register
        pub const ALRMBSSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sub seconds value
            SS: u15,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Mask the most-significant bits starting
            /// at this bit
            MASKSS: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x4c);

        /// address: 0x40002850
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ALRAF
            ALRAF: u1,
            /// ALRBF
            ALRBF: u1,
            /// WUTF
            WUTF: u1,
            /// TSF
            TSF: u1,
            /// TSOVF
            TSOVF: u1,
            /// ITSF
            ITSF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x50);

        /// address: 0x40002854
        /// masked interrupt status
        /// register
        pub const MISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ALRAMF
            ALRAMF: u1,
            /// ALRBMF
            ALRBMF: u1,
            /// WUTMF
            WUTMF: u1,
            /// TSMF
            TSMF: u1,
            /// TSOVMF
            TSOVMF: u1,
            /// ITSMF
            ITSMF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x54);

        /// address: 0x4000285c
        /// status clear register
        pub const SCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// CALRAF
            CALRAF: u1,
            /// CALRBF
            CALRBF: u1,
            /// CWUTF
            CWUTF: u1,
            /// CTSF
            CTSF: u1,
            /// CTSOVF
            CTSOVF: u1,
            /// CITSF
            CITSF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x5c);
    };

    /// General purpose timers
    pub const TIM14 = struct {
        pub const base_address = 0x40002000;

        /// address: 0x40002000
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            reserved3: u1,
            /// UIF status bit remapping
            UIFREMAP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x0);

        /// address: 0x4000200c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0xc);

        /// address: 0x40002010
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x10);

        /// address: 0x40002014
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x14);

        /// address: 0x40002018
        /// capture/compare mode register 1 (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// CC1S
            CC1S: u2,
            /// OC1FE
            OC1FE: u1,
            /// OC1PE
            OC1PE: u1,
            /// OC1M
            OC1M: u3,
            /// OC1CE
            OC1CE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Output Compare 1 mode - bit
            /// 3
            OC1M_3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x18);

        /// address: 0x40002018
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            ICPCS: u2,
            /// Input capture 1 filter
            IC1F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x18);

        /// address: 0x40002020
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            reserved0: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x20);

        /// address: 0x40002024
        /// counter
        pub const CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// low counter value
            CNT: u16,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// UIF Copy
            UIFCPY: u1,
        }), base_address + 0x24);

        /// address: 0x40002028
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4000202c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);

        /// address: 0x40002034
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x34);

        /// address: 0x40002068
        /// TIM timer input selection
        /// register
        pub const TISEL = @intToPtr(*volatile MmioInt(32, u4), base_address + 0x68);
    };

    /// General-purpose-timers
    pub const TIM2 = struct {
        pub const base_address = 0x40000000;

        /// address: 0x40000000
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            /// Direction
            DIR: u1,
            /// Center-aligned mode
            /// selection
            CMS: u2,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            reserved0: u1,
            /// UIF status bit remapping
            UIFREMAP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x0);

        /// address: 0x40000004
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/compare DMA
            /// selection
            CCDS: u1,
            /// Master mode selection
            MMS: u3,
            /// TI1 selection
            TI1S: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x40000008
        /// slave mode control register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3,
            /// OCREF clear selection
            OCCS: u1,
            /// Trigger selection
            TS: u3,
            /// Master/Slave mode
            MSM: u1,
            /// External trigger filter
            ETF: u4,
            /// External trigger prescaler
            ETPS: u2,
            /// External clock enable
            ECE: u1,
            /// External trigger polarity
            ETP: u1,
            /// Slave mode selection - bit
            /// 3
            SMS_3: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Trigger selection
            TS_4_3: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x8);

        /// address: 0x4000000c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            /// Capture/Compare 2 interrupt
            /// enable
            CC2IE: u1,
            /// Capture/Compare 3 interrupt
            /// enable
            CC3IE: u1,
            /// Capture/Compare 4 interrupt
            /// enable
            CC4IE: u1,
            reserved0: u1,
            /// Trigger interrupt enable
            TIE: u1,
            reserved1: u1,
            /// Update DMA request enable
            UDE: u1,
            /// Capture/Compare 1 DMA request
            /// enable
            CC1DE: u1,
            /// Capture/Compare 2 DMA request
            /// enable
            CC2DE: u1,
            /// Capture/Compare 3 DMA request
            /// enable
            CC3DE: u1,
            /// Capture/Compare 4 DMA request
            /// enable
            CC4DE: u1,
            reserved2: u1,
            /// Trigger DMA request enable
            TDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40000010
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            /// Capture/Compare 2 interrupt
            /// flag
            CC2IF: u1,
            /// Capture/Compare 3 interrupt
            /// flag
            CC3IF: u1,
            /// Capture/Compare 4 interrupt
            /// flag
            CC4IF: u1,
            reserved0: u1,
            /// Trigger interrupt flag
            TIF: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            /// Capture/compare 2 overcapture
            /// flag
            CC2OF: u1,
            /// Capture/Compare 3 overcapture
            /// flag
            CC3OF: u1,
            /// Capture/Compare 4 overcapture
            /// flag
            CC4OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x10);

        /// address: 0x40000014
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            /// Capture/compare 2
            /// generation
            CC2G: u1,
            /// Capture/compare 3
            /// generation
            CC3G: u1,
            /// Capture/compare 4
            /// generation
            CC4G: u1,
            reserved0: u1,
            /// Trigger generation
            TG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x14);

        /// address: 0x40000018
        /// capture/compare mode register 1 (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output compare 1 mode
            OC1M: u3,
            /// Output compare 1 clear
            /// enable
            OC1CE: u1,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Output compare 2 fast
            /// enable
            OC2FE: u1,
            /// Output compare 2 preload
            /// enable
            OC2PE: u1,
            /// Output compare 2 mode
            OC2M: u3,
            /// Output compare 2 clear
            /// enable
            OC2CE: u1,
            /// Output Compare 1 mode - bit
            /// 3
            OC1M_3: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Output Compare 2 mode - bit
            /// 3
            OC2M_3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x18);

        /// address: 0x40000018
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            IC1PSC: u2,
            /// Input capture 1 filter
            IC1F: u4,
            /// Capture/compare 2
            /// selection
            CC2S: u2,
            /// Input capture 2 prescaler
            IC2PSC: u2,
            /// Input capture 2 filter
            IC2F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4000001c
        /// capture/compare mode register 2 (output
        /// mode)
        pub const CCMR2_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3
            /// selection
            CC3S: u2,
            /// Output compare 3 fast
            /// enable
            OC3FE: u1,
            /// Output compare 3 preload
            /// enable
            OC3PE: u1,
            /// Output compare 3 mode
            OC3M: u3,
            /// Output compare 3 clear
            /// enable
            OC3CE: u1,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Output compare 4 fast
            /// enable
            OC4FE: u1,
            /// Output compare 4 preload
            /// enable
            OC4PE: u1,
            /// Output compare 4 mode
            OC4M: u3,
            /// Output compare 4 clear
            /// enable
            OC4CE: u1,
            /// Output Compare 3 mode - bit
            /// 3
            OC3M_3: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Output Compare 4 mode - bit
            /// 3
            OC4M_3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1c);

        /// address: 0x4000001c
        /// capture/compare mode register 2 (input
        /// mode)
        pub const CCMR2_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3
            /// selection
            CC3S: u2,
            /// Input capture 3 prescaler
            IC3PSC: u2,
            /// Input capture 3 filter
            IC3F: u4,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Input capture 4 prescaler
            IC4PSC: u2,
            /// Input capture 4 filter
            IC4F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40000020
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            reserved0: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            /// Capture/Compare 2 output
            /// enable
            CC2E: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2P: u1,
            reserved1: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2NP: u1,
            /// Capture/Compare 3 output
            /// enable
            CC3E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3P: u1,
            reserved2: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3NP: u1,
            /// Capture/Compare 4 output
            /// enable
            CC4E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC4P: u1,
            reserved3: u1,
            /// Capture/Compare 4 output
            /// Polarity
            CC4NP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x20);

        /// address: 0x40000024
        /// counter
        pub const CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low counter value
            CNT_L: u16,
            /// High counter value (TIM2
            /// only)
            CNT_H: u16,
        }), base_address + 0x24);

        /// address: 0x40000028
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4000002c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Auto-reload value
            ARR_L: u16,
            /// High Auto-reload value (TIM2
            /// only)
            ARR_H: u16,
        }), base_address + 0x2c);

        /// address: 0x40000034
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare 1
            /// value
            CCR1_L: u16,
            /// High Capture/Compare 1 value (TIM2
            /// only)
            CCR1_H: u16,
        }), base_address + 0x34);

        /// address: 0x40000038
        /// capture/compare register 2
        pub const CCR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare 2
            /// value
            CCR2_L: u16,
            /// High Capture/Compare 2 value (TIM2
            /// only)
            CCR2_H: u16,
        }), base_address + 0x38);

        /// address: 0x4000003c
        /// capture/compare register 3
        pub const CCR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare value
            CCR3_L: u16,
            /// High Capture/Compare value (TIM2
            /// only)
            CCR3_H: u16,
        }), base_address + 0x3c);

        /// address: 0x40000040
        /// capture/compare register 4
        pub const CCR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare value
            CCR4_L: u16,
            /// High Capture/Compare value (TIM2
            /// only)
            CCR4_H: u16,
        }), base_address + 0x40);

        /// address: 0x40000048
        /// DMA control register
        pub const DCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA burst length
            DBL: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x48);

        /// address: 0x4000004c
        /// DMA address for full transfer
        pub const DMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA register for burst
            /// accesses
            DMAB: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);

        /// address: 0x40000050
        /// TIM option register
        pub const OR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IOCREF_CLR
            IOCREF_CLR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x50);

        /// address: 0x40000060
        /// TIM alternate function option register
        /// 1
        pub const AF1 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// External trigger source
            /// selection
            ETRSEL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x60);

        /// address: 0x40000068
        /// TIM alternate function option register
        /// 1
        pub const TISEL = @intToPtr(*volatile Mmio(32, packed struct {
            /// TI1SEL
            TI1SEL: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// TI2SEL
            TI2SEL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x68);
    };
    pub const TIM3 = struct {
        pub const base_address = 0x40000400;

        /// address: 0x40000400
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            /// Direction
            DIR: u1,
            /// Center-aligned mode
            /// selection
            CMS: u2,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            reserved0: u1,
            /// UIF status bit remapping
            UIFREMAP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x0);

        /// address: 0x40000404
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/compare DMA
            /// selection
            CCDS: u1,
            /// Master mode selection
            MMS: u3,
            /// TI1 selection
            TI1S: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x40000408
        /// slave mode control register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3,
            /// OCREF clear selection
            OCCS: u1,
            /// Trigger selection
            TS: u3,
            /// Master/Slave mode
            MSM: u1,
            /// External trigger filter
            ETF: u4,
            /// External trigger prescaler
            ETPS: u2,
            /// External clock enable
            ECE: u1,
            /// External trigger polarity
            ETP: u1,
            /// Slave mode selection - bit
            /// 3
            SMS_3: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Trigger selection
            TS_4_3: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x8);

        /// address: 0x4000040c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            /// Capture/Compare 2 interrupt
            /// enable
            CC2IE: u1,
            /// Capture/Compare 3 interrupt
            /// enable
            CC3IE: u1,
            /// Capture/Compare 4 interrupt
            /// enable
            CC4IE: u1,
            reserved0: u1,
            /// Trigger interrupt enable
            TIE: u1,
            reserved1: u1,
            /// Update DMA request enable
            UDE: u1,
            /// Capture/Compare 1 DMA request
            /// enable
            CC1DE: u1,
            /// Capture/Compare 2 DMA request
            /// enable
            CC2DE: u1,
            /// Capture/Compare 3 DMA request
            /// enable
            CC3DE: u1,
            /// Capture/Compare 4 DMA request
            /// enable
            CC4DE: u1,
            reserved2: u1,
            /// Trigger DMA request enable
            TDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40000410
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            /// Capture/Compare 2 interrupt
            /// flag
            CC2IF: u1,
            /// Capture/Compare 3 interrupt
            /// flag
            CC3IF: u1,
            /// Capture/Compare 4 interrupt
            /// flag
            CC4IF: u1,
            reserved0: u1,
            /// Trigger interrupt flag
            TIF: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            /// Capture/compare 2 overcapture
            /// flag
            CC2OF: u1,
            /// Capture/Compare 3 overcapture
            /// flag
            CC3OF: u1,
            /// Capture/Compare 4 overcapture
            /// flag
            CC4OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x10);

        /// address: 0x40000414
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            /// Capture/compare 2
            /// generation
            CC2G: u1,
            /// Capture/compare 3
            /// generation
            CC3G: u1,
            /// Capture/compare 4
            /// generation
            CC4G: u1,
            reserved0: u1,
            /// Trigger generation
            TG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x14);

        /// address: 0x40000418
        /// capture/compare mode register 1 (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output compare 1 mode
            OC1M: u3,
            /// Output compare 1 clear
            /// enable
            OC1CE: u1,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Output compare 2 fast
            /// enable
            OC2FE: u1,
            /// Output compare 2 preload
            /// enable
            OC2PE: u1,
            /// Output compare 2 mode
            OC2M: u3,
            /// Output compare 2 clear
            /// enable
            OC2CE: u1,
            /// Output Compare 1 mode - bit
            /// 3
            OC1M_3: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Output Compare 2 mode - bit
            /// 3
            OC2M_3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x18);

        /// address: 0x40000418
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            IC1PSC: u2,
            /// Input capture 1 filter
            IC1F: u4,
            /// Capture/compare 2
            /// selection
            CC2S: u2,
            /// Input capture 2 prescaler
            IC2PSC: u2,
            /// Input capture 2 filter
            IC2F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4000041c
        /// capture/compare mode register 2 (output
        /// mode)
        pub const CCMR2_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3
            /// selection
            CC3S: u2,
            /// Output compare 3 fast
            /// enable
            OC3FE: u1,
            /// Output compare 3 preload
            /// enable
            OC3PE: u1,
            /// Output compare 3 mode
            OC3M: u3,
            /// Output compare 3 clear
            /// enable
            OC3CE: u1,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Output compare 4 fast
            /// enable
            OC4FE: u1,
            /// Output compare 4 preload
            /// enable
            OC4PE: u1,
            /// Output compare 4 mode
            OC4M: u3,
            /// Output compare 4 clear
            /// enable
            OC4CE: u1,
            /// Output Compare 3 mode - bit
            /// 3
            OC3M_3: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Output Compare 4 mode - bit
            /// 3
            OC4M_3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x1c);

        /// address: 0x4000041c
        /// capture/compare mode register 2 (input
        /// mode)
        pub const CCMR2_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3
            /// selection
            CC3S: u2,
            /// Input capture 3 prescaler
            IC3PSC: u2,
            /// Input capture 3 filter
            IC3F: u4,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Input capture 4 prescaler
            IC4PSC: u2,
            /// Input capture 4 filter
            IC4F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40000420
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            reserved0: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            /// Capture/Compare 2 output
            /// enable
            CC2E: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2P: u1,
            reserved1: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2NP: u1,
            /// Capture/Compare 3 output
            /// enable
            CC3E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3P: u1,
            reserved2: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3NP: u1,
            /// Capture/Compare 4 output
            /// enable
            CC4E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC4P: u1,
            reserved3: u1,
            /// Capture/Compare 4 output
            /// Polarity
            CC4NP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x20);

        /// address: 0x40000424
        /// counter
        pub const CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low counter value
            CNT_L: u16,
            /// High counter value (TIM2
            /// only)
            CNT_H: u16,
        }), base_address + 0x24);

        /// address: 0x40000428
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4000042c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Auto-reload value
            ARR_L: u16,
            /// High Auto-reload value (TIM2
            /// only)
            ARR_H: u16,
        }), base_address + 0x2c);

        /// address: 0x40000434
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare 1
            /// value
            CCR1_L: u16,
            /// High Capture/Compare 1 value (TIM2
            /// only)
            CCR1_H: u16,
        }), base_address + 0x34);

        /// address: 0x40000438
        /// capture/compare register 2
        pub const CCR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare 2
            /// value
            CCR2_L: u16,
            /// High Capture/Compare 2 value (TIM2
            /// only)
            CCR2_H: u16,
        }), base_address + 0x38);

        /// address: 0x4000043c
        /// capture/compare register 3
        pub const CCR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare value
            CCR3_L: u16,
            /// High Capture/Compare value (TIM2
            /// only)
            CCR3_H: u16,
        }), base_address + 0x3c);

        /// address: 0x40000440
        /// capture/compare register 4
        pub const CCR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare value
            CCR4_L: u16,
            /// High Capture/Compare value (TIM2
            /// only)
            CCR4_H: u16,
        }), base_address + 0x40);

        /// address: 0x40000448
        /// DMA control register
        pub const DCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA burst length
            DBL: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x48);

        /// address: 0x4000044c
        /// DMA address for full transfer
        pub const DMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA register for burst
            /// accesses
            DMAB: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);

        /// address: 0x40000450
        /// TIM option register
        pub const OR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IOCREF_CLR
            IOCREF_CLR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x50);

        /// address: 0x40000460
        /// TIM alternate function option register
        /// 1
        pub const AF1 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// External trigger source
            /// selection
            ETRSEL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x60);

        /// address: 0x40000468
        /// TIM alternate function option register
        /// 1
        pub const TISEL = @intToPtr(*volatile Mmio(32, packed struct {
            /// TI1SEL
            TI1SEL: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// TI2SEL
            TI2SEL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x68);
    };

    /// Nested Vectored Interrupt
    /// Controller
    pub const NVIC = struct {
        pub const base_address = 0xe000e100;

        /// address: 0xe000e420
        /// Interrupt Priority Register 8
        pub const IPR8 = @intToPtr(*volatile u32, base_address + 0x320);
    };

    /// Memory protection unit
    pub const MPU = struct {
        pub const base_address = 0xe000ed90;

        /// address: 0xe000ed90
        /// MPU type register
        pub const MPU_TYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Separate flag
            SEPARATE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Number of MPU data regions
            DREGION: u8,
            /// Number of MPU instruction
            /// regions
            IREGION: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x0);

        /// address: 0xe000ed94
        /// MPU control register
        pub const MPU_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enables the MPU
            ENABLE: u1,
            /// Enables the operation of MPU during hard
            /// fault
            HFNMIENA: u1,
            /// Enable priviliged software access to
            /// default memory map
            PRIVDEFENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x4);

        /// address: 0xe000ed98
        /// MPU region number register
        pub const MPU_RNR = @intToPtr(*volatile Mmio(32, packed struct {
            /// MPU region
            REGION: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x8);

        /// address: 0xe000ed9c
        /// MPU region base address
        /// register
        pub const MPU_RBAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// MPU region field
            REGION: u4,
            /// MPU region number valid
            VALID: u1,
            /// Region base address field
            ADDR: u27,
        }), base_address + 0xc);

        /// address: 0xe000eda0
        /// MPU region attribute and size
        /// register
        pub const MPU_RASR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Region enable bit.
            ENABLE: u1,
            /// Size of the MPU protection
            /// region
            SIZE: u5,
            reserved0: u1,
            reserved1: u1,
            /// Subregion disable bits
            SRD: u8,
            /// memory attribute
            B: u1,
            /// memory attribute
            C: u1,
            /// Shareable memory attribute
            S: u1,
            /// memory attribute
            TEX: u3,
            reserved2: u1,
            reserved3: u1,
            /// Access permission
            AP: u3,
            reserved4: u1,
            /// Instruction access disable
            /// bit
            XN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x10);
    };

    /// SysTick timer
    pub const STK = struct {
        pub const base_address = 0xe000e010;
    };

    /// System control block
    pub const SCB = struct {
        pub const base_address = 0xe000ed00;

        /// address: 0xe000ed08
        /// Vector table offset register
        pub const VTOR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Vector table base offset
            /// field
            TBLOFF: u25,
        }), base_address + 0x8);

        /// address: 0xe000ed20
        /// System handler priority
        /// registers
        pub const SHPR3 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Priority of system handler
            /// 14
            PRI_14: u8,
            /// Priority of system handler
            /// 15
            PRI_15: u8,
        }), base_address + 0x20);
    };

    /// System configuration controller
    pub const VREFBUF = struct {
        pub const base_address = 0x40010030;

        /// address: 0x40010030
        /// VREFBUF control and status
        /// register
        pub const CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Voltage reference buffer mode enable
            /// This bit is used to enable the voltage reference
            /// buffer mode.
            ENVR: u1,
            /// High impedance mode This bit controls
            /// the analog switch to connect or not the VREF+ pin.
            /// Refer to Table196: VREF buffer modes for the mode
            /// descriptions depending on ENVR bit
            /// configuration.
            HIZ: u1,
            reserved0: u1,
            /// Voltage reference buffer
            /// ready
            VRR: u1,
            /// Voltage reference scale These bits
            /// select the value generated by the voltage reference
            /// buffer. Other: Reserved
            VRS: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x0);

        /// address: 0x40010034
        /// VREFBUF calibration control
        /// register
        pub const CCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Trimming code These bits are
            /// automatically initialized after reset with the
            /// trimming value stored in the Flash memory during the
            /// production test. Writing into these bits allows to
            /// tune the internal reference buffer
            /// voltage.
            TRIM: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x4);
    };

    /// MCU debug component
    pub const DBG = struct {
        pub const base_address = 0x40015800;

        /// address: 0x40015800
        /// DBGMCU_IDCODE
        pub const IDCODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Device identifier
            DEV_ID: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Revision identifie
            REV_ID: u16,
        }), base_address + 0x0);

        /// address: 0x40015804
        /// Debug MCU configuration
        /// register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Debug Stop mode
            DBG_STOP: u1,
            /// Debug Standby mode
            DBG_STANDBY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x4);

        /// address: 0x40015808
        /// Debug MCU APB1 freeze
        /// register1
        pub const APB_FZ1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TIM2 counter stopped when core is
            /// halted
            DBG_TIM2_STOP: u1,
            /// TIM3 counter stopped when core is
            /// halted
            DBG_TIM3_STOP: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// RTC counter stopped when core is
            /// halted
            DBG_RTC_STOP: u1,
            /// Window watchdog counter stopped when
            /// core is halted
            DBG_WWDG_STOP: u1,
            /// Independent watchdog counter stopped
            /// when core is halted
            DBG_IWDG_STOP: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// I2C1 SMBUS timeout counter stopped when
            /// core is halted
            DBG_I2C1_STOP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x8);

        /// address: 0x4001580c
        /// Debug MCU APB1 freeze register
        /// 2
        pub const APB_FZ2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// TIM1 counter stopped when core is
            /// halted
            DBG_TIM1_STOP: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// DBG_TIM14_STOP
            DBG_TIM14_STOP: u1,
            reserved14: u1,
            /// DBG_TIM16_STOP
            DBG_TIM16_STOP: u1,
            /// DBG_TIM17_STOP
            DBG_TIM17_STOP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xc);
    };

    /// Nested vectored interrupt
    /// controller
    pub const NVIC_STIR = struct {
        pub const base_address = 0xe000ef00;

        /// address: 0xe000ef00
        /// Software trigger interrupt
        /// register
        pub const STIR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Software generated interrupt
            /// ID
            INTID: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x0);
    };

    /// System control block ACTLR
    pub const SCB_ACTRL = struct {
        pub const base_address = 0xe000e008;

        /// address: 0xe000e008
        /// Auxiliary control register
        pub const ACTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// DISMCYCINT
            DISMCYCINT: u1,
            /// DISDEFWBUF
            DISDEFWBUF: u1,
            /// DISFOLD
            DISFOLD: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// DISFPCA
            DISFPCA: u1,
            /// DISOOFP
            DISOOFP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);
    };

    /// Floating point unit CPACR
    pub const FPU_CPACR = struct {
        pub const base_address = 0xe000ed88;

        /// address: 0xe000ed88
        /// Coprocessor access control
        /// register
        pub const CPACR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            /// CP
            CP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x0);
    };

    /// Floting point unit
    pub const FPU = struct {
        pub const base_address = 0xe000ef34;

        /// address: 0xe000ef34
        /// Floating-point context control
        /// register
        pub const FPCCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// LSPACT
            LSPACT: u1,
            /// USER
            USER: u1,
            reserved0: u1,
            /// THREAD
            THREAD: u1,
            /// HFRDY
            HFRDY: u1,
            /// MMRDY
            MMRDY: u1,
            /// BFRDY
            BFRDY: u1,
            reserved1: u1,
            /// MONRDY
            MONRDY: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            /// LSPEN
            LSPEN: u1,
            /// ASPEN
            ASPEN: u1,
        }), base_address + 0x0);

        /// address: 0xe000ef38
        /// Floating-point context address
        /// register
        pub const FPCAR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Location of unpopulated
            /// floating-point
            ADDRESS: u29,
        }), base_address + 0x4);

        /// address: 0xe000ef3c
        /// Floating-point status control
        /// register
        pub const FPSCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Invalid operation cumulative exception
            /// bit
            IOC: u1,
            /// Division by zero cumulative exception
            /// bit.
            DZC: u1,
            /// Overflow cumulative exception
            /// bit
            OFC: u1,
            /// Underflow cumulative exception
            /// bit
            UFC: u1,
            /// Inexact cumulative exception
            /// bit
            IXC: u1,
            reserved0: u1,
            reserved1: u1,
            /// Input denormal cumulative exception
            /// bit.
            IDC: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Rounding Mode control
            /// field
            RMode: u2,
            /// Flush-to-zero mode control
            /// bit:
            FZ: u1,
            /// Default NaN mode control
            /// bit
            DN: u1,
            /// Alternative half-precision control
            /// bit
            AHP: u1,
            reserved16: u1,
            /// Overflow condition code
            /// flag
            V: u1,
            /// Carry condition code flag
            C: u1,
            /// Zero condition code flag
            Z: u1,
            /// Negative condition code
            /// flag
            N: u1,
        }), base_address + 0x8);
    };

    /// System configuration controller
    pub const SYSCFG_ITLINE = struct {
        pub const base_address = 0x40010080;

        /// address: 0x40010100
        /// interrupt line 0 status
        /// register
        pub const ITLINE0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Window watchdog interrupt pending
            /// flag
            WWDG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x80);

        /// address: 0x40010104
        /// interrupt line 1 status
        /// register
        pub const ITLINE1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// PVD supply monitoring interrupt request
            /// pending (EXTI line 16).
            PVDOUT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x84);

        /// address: 0x40010108
        /// interrupt line 2 status
        /// register
        pub const ITLINE2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TAMP
            TAMP: u1,
            /// RTC
            RTC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x88);

        /// address: 0x4001010c
        /// interrupt line 3 status
        /// register
        pub const ITLINE3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// FLASH_ITF
            FLASH_ITF: u1,
            /// FLASH_ECC
            FLASH_ECC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x8c);

        /// address: 0x40010110
        /// interrupt line 4 status
        /// register
        pub const ITLINE4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// RCC
            RCC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x90);

        /// address: 0x40010114
        /// interrupt line 5 status
        /// register
        pub const ITLINE5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// EXTI0
            EXTI0: u1,
            /// EXTI1
            EXTI1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x94);

        /// address: 0x40010118
        /// interrupt line 6 status
        /// register
        pub const ITLINE6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// EXTI2
            EXTI2: u1,
            /// EXTI3
            EXTI3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x98);

        /// address: 0x4001011c
        /// interrupt line 7 status
        /// register
        pub const ITLINE7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// EXTI4
            EXTI4: u1,
            /// EXTI5
            EXTI5: u1,
            /// EXTI6
            EXTI6: u1,
            /// EXTI7
            EXTI7: u1,
            /// EXTI8
            EXTI8: u1,
            /// EXTI9
            EXTI9: u1,
            /// EXTI10
            EXTI10: u1,
            /// EXTI11
            EXTI11: u1,
            /// EXTI12
            EXTI12: u1,
            /// EXTI13
            EXTI13: u1,
            /// EXTI14
            EXTI14: u1,
            /// EXTI15
            EXTI15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x9c);

        /// address: 0x40010124
        /// interrupt line 9 status
        /// register
        pub const ITLINE9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA1_CH1
            DMA1_CH1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xa4);

        /// address: 0x40010128
        /// interrupt line 10 status
        /// register
        pub const ITLINE10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA1_CH1
            DMA1_CH2: u1,
            /// DMA1_CH3
            DMA1_CH3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0xa8);

        /// address: 0x4001012c
        /// interrupt line 11 status
        /// register
        pub const ITLINE11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMAMUX
            DMAMUX: u1,
            /// DMA1_CH4
            DMA1_CH4: u1,
            /// DMA1_CH5
            DMA1_CH5: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0xac);

        /// address: 0x40010130
        /// interrupt line 12 status
        /// register
        pub const ITLINE12 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADC
            ADC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xb0);

        /// address: 0x40010134
        /// interrupt line 13 status
        /// register
        pub const ITLINE13 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TIM1_CCU
            TIM1_CCU: u1,
            /// TIM1_TRG
            TIM1_TRG: u1,
            /// TIM1_UPD
            TIM1_UPD: u1,
            /// TIM1_BRK
            TIM1_BRK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0xb4);

        /// address: 0x40010138
        /// interrupt line 14 status
        /// register
        pub const ITLINE14 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TIM1_CC
            TIM1_CC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xb8);

        /// address: 0x4001013c
        /// interrupt line 15 status
        /// register
        pub const ITLINE15 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TIM2
            TIM2: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xbc);

        /// address: 0x40010140
        /// interrupt line 16 status
        /// register
        pub const ITLINE16 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TIM3
            TIM3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xc0);

        /// address: 0x4001014c
        /// interrupt line 19 status
        /// register
        pub const ITLINE19 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TIM14
            TIM14: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xcc);

        /// address: 0x40010154
        /// interrupt line 21 status
        /// register
        pub const ITLINE21 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TIM16
            TIM16: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xd4);

        /// address: 0x40010158
        /// interrupt line 22 status
        /// register
        pub const ITLINE22 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TIM17
            TIM17: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xd8);

        /// address: 0x4001015c
        /// interrupt line 23 status
        /// register
        pub const ITLINE23 = @intToPtr(*volatile Mmio(32, packed struct {
            /// I2C1
            I2C1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xdc);

        /// address: 0x40010160
        /// interrupt line 24 status
        /// register
        pub const ITLINE24 = @intToPtr(*volatile Mmio(32, packed struct {
            /// I2C2
            I2C2: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xe0);

        /// address: 0x40010164
        /// interrupt line 25 status
        /// register
        pub const ITLINE25 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SPI1
            SPI1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xe4);

        /// address: 0x40010168
        /// interrupt line 26 status
        /// register
        pub const ITLINE26 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SPI2
            SPI2: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xe8);

        /// address: 0x4001016c
        /// interrupt line 27 status
        /// register
        pub const ITLINE27 = @intToPtr(*volatile Mmio(32, packed struct {
            /// USART1
            USART1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xec);

        /// address: 0x40010170
        /// interrupt line 28 status
        /// register
        pub const ITLINE28 = @intToPtr(*volatile Mmio(32, packed struct {
            /// USART2
            USART2: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0xf0);

        /// address: 0x40010174
        /// interrupt line 29 status
        /// register
        pub const ITLINE29 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// USART5
            USART5: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0xf4);
    };
};

const std = @import("std");

pub fn mmio(addr: usize, comptime size: u8, comptime PackedT: type) *volatile Mmio(size, PackedT) {
    return @intToPtr(*volatile Mmio(size, PackedT), addr);
}

pub fn Mmio(comptime size: u8, comptime PackedT: type) type {
    if ((size % 8) != 0)
        @compileError("size must be divisible by 8!");

    if (!std.math.isPowerOfTwo(size / 8))
        @compileError("size must encode a power of two number of bytes!");

    const IntT = std.meta.Int(.unsigned, size);

    if (@sizeOf(PackedT) != (size / 8))
        @compileError(std.fmt.comptimePrint("IntT and PackedT must have the same size!, they are {} and {} bytes respectively", .{ size / 8, @sizeOf(PackedT) }));

    return extern struct {
        const Self = @This();

        raw: IntT,

        pub const underlying_type = PackedT;

        pub inline fn read(addr: *volatile Self) PackedT {
            return @bitCast(PackedT, addr.raw);
        }

        pub inline fn write(addr: *volatile Self, val: PackedT) void {
            // This is a workaround for a compiler bug related to miscompilation
            // If the tmp var is not used, result location will fuck things up
            var tmp = @bitCast(IntT, val);
            addr.raw = tmp;
        }

        pub inline fn modify(addr: *volatile Self, fields: anytype) void {
            var val = read(addr);
            inline for (@typeInfo(@TypeOf(fields)).Struct.fields) |field| {
                @field(val, field.name) = @field(fields, field.name);
            }
            write(addr, val);
        }

        pub inline fn toggle(addr: *volatile Self, fields: anytype) void {
            var val = read(addr);
            inline for (@typeInfo(@TypeOf(fields)).Struct.fields) |field| {
                @field(val, @tagName(field.default_value.?)) = !@field(val, @tagName(field.default_value.?));
            }
            write(addr, val);
        }
    };
}

pub fn MmioInt(comptime size: u8, comptime T: type) type {
    return extern struct {
        const Self = @This();

        raw: std.meta.Int(.unsigned, size),

        pub inline fn read(addr: *volatile Self) T {
            return @truncate(T, addr.raw);
        }

        pub inline fn modify(addr: *volatile Self, val: T) void {
            const Int = std.meta.Int(.unsigned, size);
            const mask = ~@as(Int, (1 << @bitSizeOf(T)) - 1);

            var tmp = addr.raw;
            addr.raw = (tmp & mask) | val;
        }
    };
}

pub fn mmioInt(addr: usize, comptime size: usize, comptime T: type) *volatile MmioInt(size, T) {
    return @intToPtr(*volatile MmioInt(size, T), addr);
}

pub const InterruptVector = extern union {
    C: fn () callconv(.C) void,
    Naked: fn () callconv(.Naked) void,
    // Interrupt is not supported on arm
};

const unhandled = InterruptVector{
    .C = struct {
        fn tmp() callconv(.C) noreturn {
            @panic("unhandled interrupt");
        }
    }.tmp,
};
